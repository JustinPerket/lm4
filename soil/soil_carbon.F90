module soil_carbon_mod

!Don't use external model stuff if compiling standalone version
#ifndef STANDALONE_SOIL_CARBON

#include "../shared/debug.inc"

use constants_mod, only : pi, dens_h2o
use land_constants_mod, only : Rugas, seconds_per_year
use fms_mod, only: check_nml_error, file_exist, write_version_number, close_file, &
            stdlog, mpp_pe, mpp_root_pe, error_mesg, FATAL, NOTE
use vegn_data_mod, only: K1,K2
use land_numerics_mod,only: tridiag
use land_debug_mod, only: get_current_point, is_watch_point

#ifdef INTERNAL_FILE_NML
use mpp_mod, only: input_nml_file
#else
use fms_mod, only: open_namelist_file
#endif
#endif


!End of external model stuff

implicit none

private


! ==== public interfaces =====================================================
public :: soil_pool
public :: soilMaxCohorts

public :: update_pool
public :: add_litter
public :: add_C_N_to_cohorts
public :: add_C_N_to_rhizosphere
public :: combine_pools
public :: poolTotals
public :: pool_total_carbon
public :: init_soil_pool
public :: read_soil_carbon_namelist
public :: remove_C_N_fraction_from_pool

public :: tracer_leaching_with_litter
public :: cull_cohorts
public :: transfer_pool_fraction
public :: retrieve_DOC ! report DOC concentration to hlsp_hydrology
public :: retrieve_DON
public :: retrieve_dissolved_mineral_N
public :: mycorrhizal_mineral_N_uptake_rate
public :: mycorrhizal_decomposition
public :: hypothetical_mycorrhizal_decomposition

#ifndef STANDALONE_SOIL_CARBON
public :: get_pool_data_accessors
public :: A_function
#endif

public :: debug_pool

public :: soil_carbon_option, SOILC_CENTURY, SOILC_CENTURY_BY_LAYER, SOILC_CORPSE, SOILC_CORPSE_N

public :: N_limit_scheme!x2z
public :: soil_NO3_deposition!x2z
public :: soil_NH4_deposition!x2z

! =====end of public interfaces ==============================================


! ==== module constants ======================================================
integer,parameter,public::n_c_types=3  !Carbon chemical species (Cellulose, lignin, microbial products)
character(len=*), parameter   :: &
     version     = '$Id$', &
     tagname     = '$Name$', &
     module_name = 'soil_carbon_mod'
integer, parameter :: SOILC_CENTURY          = 1
integer, parameter :: SOILC_CENTURY_BY_LAYER = 2
integer, parameter :: SOILC_CORPSE           = 3
integer, parameter :: SOILC_CORPSE_N         = 4  ! This option enables all nitrogen code
integer, parameter :: init_n_cohorts = 3 ! initial number of cohorts in a litter pool

!For fixed rhizosphere mode: Separate cohorts just for rhizosphere and bulk soil
integer,parameter::RHIZ=1,BULK=2

! Options for N_limit_scheme
! NLIM_DOWNREGULATE limits decomposition so it stops when N is limiting
! NLIM_OVERFLOW decomposes carbon at potential decomposition rate and sends excess carbon
!   (as determined by N availability) to overflow respiration
integer,parameter::NLIM_DOWNREGULATE=1,NLIM_OVERFLOW=2

#ifdef STANDALONE_SOIL_CARBON
real,parameter::pi=3.141592
real,parameter::Rugas=8.314472
real,parameter::dens_h2o=1000.
integer,parameter::FATAL=0,NOTE=1
real,parameter :: seconds_per_year=86400.0*365.0
#endif

! ==== types =================================================================

!Individual litter cohort with its own carbon pools
type litterCohort
    !Carbon pools
    real,dimension(n_c_types)::litterC  !Carbon substrate. Relative amounts of C species are important for resp rate
    real,dimension(n_c_types)::protectedC !Aggregate and mineral complex C
    real::livingMicrobeC               !Current carbon mass of live microbes
    real::CO2                          !Cumulative CO2 generated by decomposition
    real::Rtot                         !Cumulative decomposition (includes double counting through microbial products)
    !Original C
    real::originalLitterC              !Keep track for carbon balance check

    real,dimension(n_c_types)::litterN  !x2z Nitrogen substrate
    real,dimension(n_c_types)::protectedN !x2z
    real::livingMicrobeN                !x2z Current N mass of live microbes
    real*8::IMM_N_max                	!x2z Maximum inorganic N immobilization (what's available in that time step)
    real*8::IMM_N_gross                	!x2z Actual gross inorganic N immobilization
    real*8::MINER_gross                	!x2z Actual gross inorganic N mineralization
    real*8::MINER_prod                	!x2z Actual gross inorganic N mineralization
    real*8::IMM_Nprod                	!x2z Actual gross inorganic N mineralization

real::originalLitterN              !Keep track for N balance check
end type litterCohort


!Pool type, can hold multiple individual litter/carbon cohorts
type soil_pool
    integer::max_cohorts    !Maximum number of cohorts, allows different pools to have different maximum heterogeneity
    integer::n_cohorts = 0  !actual number of cohorts in the pool
    real::protection_rate   !Pool-specific rate that carbon is transferred to protected pool (aggregate and chemical protection)
    real::Qmax              !Pool DOC sorption capacity (See Mayes et al 2012)
    type(litterCohort),allocatable::litterCohorts(:)
    real::dissolved_carbon(n_c_types)


    real::protection_rate_N   !
    real::dissolved_nitrogen(n_c_types)
    real:: ammonium, nitrate
    real:: nitrif, denitrif
end type soil_pool


!==== module variables =======================================================



!---- namelist ---------------------------------------------------------------
character(32) :: soil_carbon_model_to_use = 'CENTURY-like' ! or 'CENTURY-like-by-layer', or 'CORPSE', or 'CORPSE-N'
logical                   :: use_rhizosphere_cohort=.FALSE.  !Use 2 fixed cohorts for rhizosphere and bulk soil if true
logical                   :: denitrif_first_order=.FALSE.   ! Do first-order denitrification from nitrate pool (not as part of OM decomp) if true
real,dimension(n_c_types) :: Ea=(/37e3,54e3,50e3/)          !Activation energy (kJ/mol)
real*8					   :: Ea_NH4=37e3	                 !Activation energy for immobilization of ammonium (kJ/mol)
real*8					   :: Ea_NO3=37e3	                 !Activation energy for immobilization of nitrate (kJ/mol)
real*8					   :: Ea_nitrif=37e3                 !Activation energy for nitrification of ammonium  (kJ/mol)
real*8					   :: Ea_denitr=37e3				 !Activation energy for uptake of inorganic nitrogen  (kJ/mol)
real*8             :: Vmax_myc_min_N_uptk=365.0    ! Vmax of mycorrhizal uptake of mineral N (year-1)
real*8             :: k_myc_min_N_uptk=0.01       ! half-saturation constant for mycorrhizal uptake of mineral N (kgC/m3 of mycorrhizal biomass)
real*8             :: k_myc_decomp=0.01           ! half-saturation constant for mycorrhizal decomposition
real,dimension(n_c_types) :: vmaxref_myc_decomp=(/4500e0,25e0,600e0/)
real,dimension(n_c_types) :: vmaxref=(/4e1,1e1,.5e1/)       !Vmax at reference temperature (yr-1)
real,dimension(n_c_types) :: kC=(/.5,.1,0.05/)              !Michaelis-Menton C parameter (dimensionless)
real                      :: Tmic=0.2                       !Microbial mean lifetime (yr)
real                      :: et=0.5                         !Fraction of microbial turnover not converted to CO2
real*8                     :: V_NH4_ref=0.03                 !Ref. Microbes Efficiency of Ammonium immobilizatiion (yr-1 (kg-microbial-C-biomass/m2)-1) uptake rate per unit microbe C-biomass
real*8                     :: V_NO3_ref=0.01                 !Ref. Microbes Efficiency of Nitrate immobilizatiion
real*8					   :: Knitr_ref=0.01				 !Nitirification constant at reference temperature  (yr-1)
real*8					   :: Kdenitr_ref=0.01				 !Denitirification constant at reference temperature  (yr-1)
real*8,dimension(n_c_types) :: vmaxref_denitrif=(/450e0,2.5e0,60e0/) ! Organic matter decomp rates with denitrification as electron acceptor
real*8             :: k_denitrif=1e-2          ! Half saturation constant for denitrification (kgNO3-N/kgNO3-N demand/year)
real*8             :: denitrif_NO3_factor=0.18
real*8                     :: CN_microb=8                    !Fixed microbial C:N ratio

real,dimension(n_c_types) :: eup=(/0.6,0.2,0.1/)            !Fraction of degraded C that goes into microbial biomass
real,dimension(n_c_types) :: eup_myc=(/0.6,0.2,0.1/)            !Fraction of degraded C that goes into mycorrhizal biomass
real*8,dimension(n_c_types) :: mup(n_c_types)=(/0.9,0.9,0.9/)  !Fraction of decomposed N that goes into microbial biomass

real                      :: minMicrobeC=1e-5               !Minimum microbial biomass (prevents complete collapse if > 0.0)
real*8					  :: gamma_nitr=0.6				 !Proportion of ammonium that is NOT lost as gas during the nitrification process

real                      :: D=3.0                          !Diffusion coefficient (for carbon and enzyme movement)
real                      :: enzfrac=1.0                    !Relative amount of enzymes produced by microbes
real                      :: tProtected=10.0                !Turnover rate of protected carbon (yr-1)
real*8                     :: tProtected_N=10.0              !Turnover rate of protected nitrogen (yr-1)
real                      :: protection_rate=1.0            !Rate that carbon becomes protected (yr-1 kg-microbial-biomass-1)
real*8                     :: protection_rate_N=1.0

real,dimension(n_c_types) :: protection_species=(/0.5,0.5,1.0/)  !Relative protection rate of each flavor

real*8,dimension(n_c_types) :: protection_species_N=(/0.5,0.5,1.0/)

real                      :: C_leaching_solubility=0.5       !Amount of carbon dissolves in soil water at saturated moisture (fraction)
real*8                     :: N_leaching_solubility=0.5	   !Amount of nitrogen dissolves in soil water at saturated moisture (fraction)

real,dimension(n_c_types) :: C_flavor_relative_solubility=(/1.0,1.0,1.0/) !For each C flavor, relative to 1.0
real*8,dimension(n_c_types) :: N_flavor_relative_solubility=(/1.0,1.0,1.0/) !For each N flavor, relative to 1.0

real                      :: protected_relative_solubility=1.0 !Relative to 1.0
real*8                     :: N_protected_relative_solubility=1.0 !Relative to 1.0

real                      :: DOC_deposition_rate=1.0       !Amount of dissolved C deposited after leaching (fraction)
real*8                     :: DON_deposition_rate=1.0       !Amount of dissolved N deposited after leaching (fraction)

real                      :: gas_diffusion_exp=2.5          !Exponent for gas diffusion power law dependence on theta
                                                            !See Meslin et al 2010, SSAJ
real                      :: litterDensity=22.0             !C density of litter layer (kg/m3)
                                                            !22.0 roughly from Gaudinsky et al 2000
real                      :: min_anaerobic_resp_factor=0.0  !Minimum for high soil moisture Resp limitation

real                      :: denitrif_theta_min=0.5        !Minimum theta for denitrification to occur
integer                   :: soilMaxCohorts=7              !Maximum number of cohorts in soil carbon pools

real                      :: tol=1e-4                       !Tolerance for cohort carbon check
logical                   :: microbe_driven_protection=.TRUE. !Whether to use microbial biomass in protection rate
integer                   :: N_limit_scheme = NLIM_OVERFLOW  ! N limitation scheme to use: See definitions above

namelist /soil_carbon_nml/ &
            soil_carbon_model_to_use, use_rhizosphere_cohort,&
            Ea,vmaxref,kC,Tmic,et,eup,minMicrobeC,soilMaxCohorts,gas_diffusion_exp,&
            tol,enzfrac,tProtected,protection_rate,protection_species,C_leaching_solubility,C_flavor_relative_solubility,DOC_deposition_rate,&
            litterDensity,protected_relative_solubility,min_anaerobic_resp_factor,microbe_driven_protection,&
            Ea_NH4,Ea_NO3,Ea_nitrif,Ea_denitr,denitrif_theta_min,&
            V_NH4_ref,V_NO3_ref,Knitr_ref,Kdenitr_ref,&
            CN_microb,mup,gamma_nitr,tProtected_N,&
            protection_rate_N,&
            protection_species_N,&
            N_leaching_solubility,&
            N_flavor_relative_solubility,&
            N_protected_relative_solubility,&
            DON_deposition_rate,&
            N_limit_scheme,&
            Vmax_myc_min_N_uptk,k_myc_min_N_uptk,eup_myc,vmaxref_myc_decomp,k_myc_decomp,&
            vmaxref_denitrif,k_denitrif,denitrif_first_order,denitrif_NO3_factor


!---- end-of-namelist --------------------------------------------------------
integer :: soil_carbon_option = 0    ! flag specifying which soil carbon to use,
        ! one of SOILC_CENTURY, SOILC_CENTURY_BY_LAYER, SOILC_CORPSE, SOILC_CORPSE_N


contains ! -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


subroutine init_soil_pool(pool,protectionRate,Qmax,max_cohorts)
    type(soil_pool),intent(inout)::pool
    real,optional,intent(in) :: protectionRate,Qmax
    integer,optional,intent(in) :: max_cohorts

    type(litterCohort) :: newCohort

    pool%max_cohorts=soilMaxCohorts
    pool%protection_rate=protection_rate
    pool%Qmax=0.0
    pool%dissolved_carbon=0.0

    pool%dissolved_nitrogen=0.0!xz
    pool%ammonium=0.0! Should this have a nonzero initial value?
    pool%nitrate=0.0!
    pool%nitrif=0.0!xz
    pool%denitrif=0.0!xz


    IF (present(max_cohorts)) pool%max_cohorts=min(max_cohorts,soilMaxCohorts)
    IF (present(protectionRate)) pool%protection_rate=protectionRate
    IF (present(Qmax)) pool%Qmax=Qmax

    pool%n_cohorts = 0
    IF (allocated(pool%litterCohorts)) deallocate(pool%litterCohorts)

    IF (use_rhizosphere_cohort) THEN
        DO WHILE(pool%n_cohorts<max(BULK,RHIZ))
            call initializeCohort(newCohort)
            call add_cohort(pool,newCohort)
        ENDDO
    ENDIF


end subroutine init_soil_pool

! =============================================================================
#ifndef STANDALONE_SOIL_CARBON
subroutine read_soil_carbon_namelist
  integer :: unit         ! unit for namelist i/o
  integer :: io           ! i/o status for the namelist
  integer :: ierr         ! error code, returned by i/o routines
  integer :: i
  real    :: z

  call write_version_number(version, tagname)
#ifdef INTERNAL_FILE_NML
  read (input_nml_file, nml=soil_carbon_nml, iostat=io)
  ierr = check_nml_error(io, 'soil_carbon_nml')
#else
  if (file_exist('input.nml')) then
     unit = open_namelist_file()
     ierr = 1;
     do while (ierr /= 0)
        read (unit, nml=soil_carbon_nml, iostat=io, end=10)
        ierr = check_nml_error (io, 'soil_carbon_nml')
     enddo
10   continue
     call close_file (unit)
  endif
#endif
  if (mpp_pe() == mpp_root_pe()) then
     unit=stdlog()
     write(unit, nml=soil_carbon_nml)
  endif


  ! parse soil carbon option
  select case (soil_carbon_model_to_use)
  case('CENTURY-like')
    soil_carbon_option = SOILC_CENTURY
  case('CENTURY-like-by-layer')
    soil_carbon_option = SOILC_CENTURY_BY_LAYER
  case('CORPSE')
    soil_carbon_option = SOILC_CORPSE
  case('CORPSE-N')
    soil_carbon_option = SOILC_CORPSE_N
  case default
    call error_mesg('read_soil_carbon_namelist', &
        '"'//trim(soil_carbon_model_to_use)//'" is an invalid option for soil_carbon_model_to_use', FATAL)
  end select

end subroutine read_soil_carbon_namelist
#endif


#ifdef STANDALONE_SOIL_CARBON
subroutine read_soil_carbon_namelist(file)
character*(*),optional,intent(in)::file

integer :: namelistunit
namelistunit=12300
!Read parameters from namelist
if(present(file)) then
print *,'Reading soil params from namelist: ',file
OPEN(unit=namelistunit,file=file)
else
OPEN(unit=namelistunit,file='soilparams.nml')
endif
READ(unit=namelistunit,NML=soil_carbon_nml)
CLOSE(unit=namelistunit)

end subroutine
#endif

!Deposit ammonium into soil pool
subroutine soil_NH4_deposition(NH4_dep,pool)
    type(soil_pool),intent(inout) :: pool
    real*8,intent(in)::NH4_dep

    pool%ammonium=pool%ammonium+NH4_dep
end subroutine

!Deposit nitrate into soil pool
subroutine soil_NO3_deposition(NO3_dep,pool)
    type(soil_pool),intent(inout) :: pool
    real*8,intent(in)::NO3_dep

    pool%nitrate=pool%nitrate+NO3_dep
end subroutine



subroutine dissolve_carbon(pool,theta)
  type(soil_pool),intent(inout)::pool
  real,intent(in)::theta

  real :: C_dissolution_rate, N_dissolution_rate
  real :: C_protected_solubility, N_protected_solubility
  real::C_dissolved(n_c_types),protectedC_dissolved(n_c_types),livemicrobeC_dissolved
  real::N_dissolved(n_c_types),protectedN_dissolved(n_c_types),livemicrobeN_dissolved



  if(theta > 0.0) then

      C_dissolution_rate=C_leaching_solubility*theta

      !Protected carbon can dissolve, but much faster under high moisture conditions
      C_protected_solubility=theta**gas_diffusion_exp*protected_relative_solubility
      if (C_protected_solubility<0.0) C_protected_solubility=0.0
      if (C_protected_solubility>1.0) C_protected_solubility=1.0

        IF(soil_carbon_option == SOILC_CORPSE_N) THEN
              N_dissolution_rate=N_leaching_solubility*theta

              N_protected_solubility=theta**gas_diffusion_exp*N_protected_relative_solubility
              if (N_protected_solubility<0.0) N_protected_solubility=0.0
              if (N_protected_solubility>1.0) N_protected_solubility=1.0

          ELSE

              N_protected_solubility=0.0
        ENDIF


      call remove_C_N_fraction_from_pool(pool,C_dissolution_rate,N_dissolution_rate, &
                  litterC_removed=C_dissolved,protectedC_removed=protectedC_dissolved,&
                  livemicrobeC_removed=livemicrobeC_dissolved,&
                  litterN_removed=N_dissolved,protectedN_removed=protectedN_dissolved,&
                  livemicrobeN_removed=livemicrobeN_dissolved,&
                  C_protectedMobility=C_protected_solubility,livingMicrobeMobility=dfloat(0),&
                  C_litterMobility=C_flavor_relative_solubility,N_protectedMobility=N_protected_solubility,&
                  N_litterMobility=N_flavor_relative_solubility)

      C_dissolved=C_dissolved+protectedC_dissolved
      ! protected_turnover_rate=protected_turnover_rate+protectedC_dissolved/dt
      N_dissolved=N_dissolved+protectedN_dissolved
      ! protected_N_turnover_rate=protected_N_turnover_rate+protectedN_dissolved/dt

      pool%dissolved_carbon=pool%dissolved_carbon+C_dissolved
      pool%dissolved_nitrogen=pool%dissolved_nitrogen+N_dissolved

  endif


end subroutine dissolve_carbon


subroutine deposit_dissolved_C(pool)
  type(soil_pool),intent(inout)::pool
  real::deposited_C(n_c_types),deposited_N(n_c_types)

  deposited_C=DOC_deposition_rate*pool%dissolved_carbon

  where(deposited_C > pool%dissolved_carbon)
      deposited_C=pool%dissolved_carbon
      pool%dissolved_carbon=0.0
  elsewhere
      pool%dissolved_carbon=pool%dissolved_carbon-deposited_C
  end where

  IF(soil_carbon_option == SOILC_CORPSE_N) THEN
        deposited_N=DOC_deposition_rate*pool%dissolved_nitrogen
        where(deposited_N > pool%dissolved_nitrogen) !xz
            deposited_N=pool%dissolved_nitrogen  !xz  (kg/m2)
            pool%dissolved_nitrogen=dfloat(0)!xz
        elsewhere!xz
            pool%dissolved_nitrogen=pool%dissolved_nitrogen-deposited_N   !xz
        end where!xz

    ELSE

        deposited_N=0.0

  ENDIF


  call add_C_N_to_cohorts(pool,litterC=deposited_C,litterN=deposited_N)

end subroutine deposit_dissolved_C


subroutine update_pool(pool,T,theta,air_filled_porosity,liquid_water,frozen_water,dt,layerThickness,&
            fast_C_loss_rate,slow_C_loss_rate,deadmic_C_loss_rate,fast_N_loss_rate,slow_N_loss_rate,deadmic_N_loss_rate,&
            CO2prod,deadmic_C_produced,deadmic_N_produced,protected_C_produced,protected_N_produced,protected_turnover_rate,protected_N_turnover_rate,&
            nitrification,denitrification,N_mineralization,N_immobilization,badCohort)
    type(soil_pool),intent(inout)::pool
    real,intent(in)::T,theta,dt,air_filled_porosity,liquid_water,frozen_water,layerThickness
    real,intent(out)::fast_C_loss_rate,slow_C_loss_rate,deadmic_C_loss_rate,fast_N_loss_rate,slow_N_loss_rate,deadmic_N_loss_rate
    real,intent(out)::CO2prod,nitrification,denitrification,N_mineralization,N_immobilization !  kgC/m2 and kgN/m2 (not rates)
    real,intent(out)::protected_C_produced(n_c_types),protected_N_produced(n_c_types),&
        protected_turnover_rate(n_c_types),protected_N_turnover_rate(n_c_types),deadmic_C_produced,deadmic_N_produced
    integer,intent(out),optional::badCohort
    ! dt is in years!

    integer::n

    real::tempresp(n_c_types),resp(n_c_types),temp_N_decomposed(n_c_types),Ndecomp(n_c_types),temp_protected(n_c_types),temp_N_protected(n_c_types),&
            tempCO2,poolProtectedC,temp_protected_turnover_rate(n_c_types),temp_protected_N_turnover_rate(n_c_types),&
            Prate_limited(n_c_types),Prate_limited_N(n_c_types),prevC(n_c_types),prevN(n_c_types),&
            temp_deadmic_C,temp_deadmic_N,tempIMM_N,soil_IMM_N,temp_MINERAL, soil_MINERAL,temp_livemic_C,temp_livemic_N

    real::activeVolume,inactiveVolume,cohortVolume!xz
    real::nitrif,Denitrif!xz


!   if (is_watch_point()) then
!      write(*,*)'##### update_pool input ####'
!      __DEBUG4__(T,theta,dt,air_filled_porosity)
!      __DEBUG3__(liquid_water,frozen_water,layerThickness)
!      do n=1, pool%n_cohorts
!          write(*,*) 'cohort ',n
!          __DEBUG1__(pool%litterCohorts(n)%litterC)
!          __DEBUG1__(pool%litterCohorts(n)%protectedC)
!           __DEBUG2__(pool%litterCohorts(n)%livingMicrobeC,pool%litterCohorts(n)%originalLitterC)
!           __DEBUG1__(pool%litterCohorts(n)%CO2)
!       enddo
!    endif

    resp=0.0
    CO2prod=0.0
    protected_C_produced=0.0
    protected_turnover_rate=0.0
    nitrif=dfloat(0)!xz
    denitrification=0.0
    Ndecomp=dfloat(0)
    protected_N_produced=dfloat(0)
    protected_N_turnover_rate=dfloat(0)
    deadmic_C_produced=dfloat(0)
    deadmic_N_produced=dfloat(0)
    soil_IMM_N=dfloat(0)
    soil_MINERAL=dfloat(0)



    if(present(badCohort)) badCohort=0


    if(pool%nitrate<0) THEN
        call error_mesg('update_pool','Nitrate < 0',FATAL)
    endif

    if(.NOT.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    call cull_cohorts(pool)



    !Protection rate is multiplied by available space, so protected C does not exceed Pmax
    !However, the rate is not adjusted for each cohort, so it may go slightly above the pool Pmax
    ! ---   Based on conversation with Melanie Mayes, I am changing this so Qmax affects the protected
    ! ---   carbon formation rate rather than the maximum.

    Prate_limited=pool%protection_rate*protection_species*pool%Qmax
    Prate_limited_N=pool%protection_rate_N*protection_species_N*pool%Qmax

    !Need to convert originalLitterC into a meaningful volume, since it will keep increasing as cohorts are combined
    !How about this: non-mineralized C keeps volume based on estimated density
    !Volume of mineralized C is just capped at remaining layer volume, with the assumption that the mineralized portion
    !of volume for all cohorts just gets intermingled and doesn't need to sum to layer volume
!    if (is_watch_point()) then
!       write(*,*) '##### update_pool outpt #####'
!    endif


    DO n=1,pool%n_cohorts
        prevC=pool%litterCohorts(n)%litterC
        prevN=pool%litterCohorts(n)%litterN
        activeVolume=cohortCsum(pool%litterCohorts(n),.TRUE.)/litterDensity
        inactiveVolume=min(pool%litterCohorts(n)%originalLitterC/litterDensity,layerThickness)-activeVolume
        cohortVolume=activeVolume+max(0.0,inactiveVolume)
        call update_cohort(cohort=pool%litterCohorts(n),nitrate=pool%nitrate,ammonium=pool%ammonium,cohortVolume=cohortVolume,T=T,theta=max(theta,0.0),&
                        air_filled_porosity=max(air_filled_porosity,0.0),&
                        protection_rate=Prate_limited,protection_rate_N=Prate_limited_N,&
                        dt=dt,&
                        totalResp=tempresp,totalN_decomposed=temp_N_decomposed,deadmic_C_produced=temp_deadmic_C,deadmic_N_produced=temp_deadmic_N,&
                        protected_produced=temp_protected,protected_N_produced=temp_N_protected,&
                        protected_turnover_rate=temp_protected_turnover_rate,protected_N_turnover_rate=temp_protected_N_turnover_rate,&
                        CO2prod=tempCO2,IMM_Nprod=tempIMM_N,MINERAL_prod=temp_MINERAL,denitrif=denitrif,livemic_C_produced=temp_livemic_C,livemic_N_produced=temp_livemic_N)
        IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
            if(present(badCohort)) badCohort=n
            WRITE (*,*),'UPDATE_POOL: Cohort',n,'of',pool%n_cohorts,'bad'
            call print_cohort(pool%litterCohorts(n))
            WRITE (*,*),'Dissolved carbon =',pool%dissolved_carbon
            WRITE (*,*),'Latest respiration:',tempResp*dt
            WRITE (*,*),'Previous unprotected C:',prevC
            WRITE (*,*),'Previous unprotected N:',prevN
            WRITE (*,*),'Pool Nitrate:',pool%nitrate
            WRITE (*,*),'Pool ammonium:',pool%ammonium
        ENDIF

        resp=resp+tempresp
        Ndecomp=Ndecomp+temp_N_decomposed

        protected_C_produced=protected_C_produced+temp_protected
        protected_N_produced=protected_N_produced+temp_N_protected

        protected_turnover_rate=protected_turnover_rate+temp_protected_turnover_rate
        protected_N_turnover_rate=protected_N_turnover_rate+temp_protected_N_turnover_rate

        deadmic_C_produced=deadmic_C_produced+temp_deadmic_C
        deadmic_N_produced=deadmic_N_produced+temp_deadmic_N

        !livemic_C_produced=livemic_C_produced+temp_livemic_C!kg/m2
        !livemic_N_produced=livemic_N_produced+temp_livemic_N  !xz kg/m2

        CO2prod=CO2prod+tempCO2

        soil_MINERAL=soil_MINERAL+temp_MINERAL  !xz kg/m2
        soil_IMM_N=soil_IMM_N+tempIMM_N !xz kg/m2
        denitrification = denitrification + denitrif*dt ! kgN/m2

!        if (is_watch_point()) then
!           __DEBUG4__(cohortVolume,T,theta,air_filled_porosity)
!           __DEBUG3__(Prate_limited,tempCO2,CO2prod)
!        endif

    ENDDO


    ! Xin had N uptake here.  I'm moving it to somewhere in vegetation
IF (soil_carbon_option == SOILC_CORPSE_N) THEN
    !!Nitrification and denitrification after updating all cohorts
     !!!!!!!!!!!!!!xz Check to add N2O emission, change the gamma_nitr to account nitrogen lost during the nitrification and denitrification processes
    	nitrif=min(pool%ammonium,Knitrif(T)*(max(theta,0.0)**3)*max((max(air_filled_porosity,0.0))**gas_diffusion_exp,min_anaerobic_resp_factor)*pool%ammonium*dt)   !xz CHECK with Gerber's paper(or LM3 code)   kg/m2
    	!      kg/m2       kg/m2         yr-1                                                                                      kg/m2         yr
    	pool%nitrif=pool%nitrif + nitrif!xz  --BNS: changed to cumulative

            pool%ammonium=pool%ammonium-nitrif!xz
            pool%nitrate=pool%nitrate+gamma_nitr*nitrif!xz   gamma_nitr is set to 1 now.
            ! Gaseous N losses are going to break N conservation unless we keep track of them
    !!!!!!!!!!!!!!xz Check [end]

    !!!!!!!!!!!!!xz Denitrification; check with LM3 code; Currently the code only calculate the denitrification rate with Temperature, we might improve it by adding siol water content
         !!!xz CH note: check the theta condition because the denitri may work differently from the rest of proccesses
         IF(denitrif_first_order) then

          IF(theta.gt.denitrif_theta_min)THEN  !xz when the soil water content is higher than minimum soil water content(defined in the parameters), then dinitrification take a potential rate; otherwise it is 0
    			Denitrif=min(pool%nitrate,Kdenitr(T)*pool%nitrate*dt)
    			if(Denitrif.lt.dfloat(0))then
    				call error_mesg('update_pool','Denitrif < 0',FATAL)
    			endif
           ELSE
    			Denitrif=dfloat(0)
           ENDIF

           !!!!!!!!!!!!!xz update the pool
          pool%nitrate=pool%nitrate-denitrif

            denitrification=denitrif
         ENDIF



            pool%denitrif=pool%denitrif+denitrif

            nitrification=nitrif
            N_mineralization = soil_MINERAL
            N_immobilization = soil_IMM_N

ELSE

  nitrification=0.0
  denitrification=0.0
  N_mineralization = soil_MINERAL
  N_immobilization = soil_IMM_N
ENDIF

    fast_C_loss_rate=resp(1)
    slow_C_loss_rate=resp(2)
    deadmic_C_loss_rate=resp(3)

    fast_N_loss_rate=Ndecomp(1)!xz
    slow_N_loss_rate=Ndecomp(2)!xz
    deadmic_N_loss_rate=Ndecomp(3)!xz


end subroutine update_pool


!Do litter respiration and microbial turnover for one litter cohort
subroutine update_cohort(cohort,nitrate,ammonium,cohortVolume,T,theta,air_filled_porosity,protection_rate,protection_rate_N,dt,&
        totalResp,deadmic_C_produced,deadmic_N_produced,protected_produced,protected_N_produced,&
        protected_turnover_rate,protected_N_turnover_rate,CO2prod,totalN_decomposed,IMM_Nprod,MINERAL_prod,denitrif,livemic_C_produced,livemic_N_produced) !xz
    type(litterCohort),intent(inout)::cohort
    real,intent(out)::totalResp(n_c_types),CO2prod,protected_produced(n_c_types),protected_N_produced(n_c_types),protected_turnover_rate(n_c_types), &
        protected_N_turnover_rate(n_c_types),deadmic_C_produced,deadmic_N_produced,IMM_Nprod,MINERAL_prod,denitrif,livemic_C_produced,livemic_N_produced
    real,intent(in)::cohortVolume,T,theta,dt,protection_rate(n_c_types),protection_rate_N(n_c_types) !Temperature, volumetric water content, delta time
    real,intent(in)::air_filled_porosity
    real,intent(inout)::nitrate, ammonium

    real::microbeTurnover,temp_C_microbes,CN_imbalance_term,temp_N_microbes,pot_CN_imbalance_term,microbeTurnover_Npot,microbeTurnover_Nreq
    real::potential_tempResp(n_c_types),oldminC(n_c_types),tempResp(n_c_types),Max_tempResp_possible(n_c_types),prova_decomp1(n_c_types),prova_decomp2(n_c_types),N_inhibitory_factor_test(n_c_types)
    real,dimension(n_c_types)::protectedCTurnover,newProtectedC,protectedNturnover,newProtectedN

    real::totalN_decomposed(n_c_types),prova_imm1,prova_imm2,prova_imm3,prova_imm4,provaCN1,provaCN2,provaCN3
    real::pot_tempN_decomposed(n_c_types), potential_N_decomp(n_c_types),diff(n_c_types),tempN_decomposed(n_c_types)
    real::denitrif_NO3_demand ! kgN/m2/year
    real,dimension(n_c_types):: denitrif_Resp,pot_tempN_decomposed_denitrif ! kgC/m2/year
    real::carbon_supply_denitrif,nitrogen_supply_denitrif


    real::a,b,c, delta, temp_a, N_inhibitory_factor, solution1, solution2, denominator,denominator_sum,prova1,prova2,somma1,somma2,term3,provaCN_imm,dMNdt_req,dMCdt_req
    integer::i

    real:: CN_litter_3p(n_c_types)
    integer :: N_lim_state  ! Keep track of N limitation in this time step for debugging
    integer, parameter :: EXCESS_N = 1, N_LIMITED = 2, IMMOBILIZATION = 3, N_LIM_TURNED_OFF = -999

    !!!!!xz from CH code[end]
    real::maintenance_resp,overflow_resp,carbon_supply,nitrogen_supply !!BNS
    maintenance_resp=dfloat(0)
    overflow_resp=dfloat(0)
    carbon_supply=dfloat(0)
    nitrogen_supply=dfloat(0)


    CN_imbalance_term=dfloat(0)
    totalResp=dfloat(0)
    potential_tempResp=dfloat(0)
    tempResp=dfloat(0)
    CO2prod=dfloat(0)
    deadmic_C_produced=dfloat(0)
    deadmic_N_produced=dfloat(0)
    a=dfloat(0)
    b=dfloat(0)
    c=dfloat(0)
    delta=dfloat(0)
    temp_a=dfloat(0)
    livemic_C_produced=dfloat(0)
    livemic_N_produced=dfloat(0)

    totalN_decomposed=dfloat(0)
    pot_tempN_decomposed=dfloat(0)
    tempN_decomposed=dfloat(0)
    potential_N_decomp(n_c_types)=dfloat(0)

    MINERAL_prod=dfloat(0)
    IMM_Nprod=dfloat(0)



    if(.NOT. check_cohort(cohort)) THEN
       call print_cohort(cohort)
       call error_mesg('update_cohort','Cohort invalid at beginning of subroutine',FATAL)
    endif


    !Calculate potential respiration rate (if not N limited)
    !Litter
    potential_tempResp=Resp(cohort%litterC,cohort%livingMicrobeC,T,theta,air_filled_porosity)

    ! Respiration of carbon supported by denitrification rather than oxygen; kgC/m2/yr
    denitrif_Resp=Resp_denitrif(cohort%litterC,cohort%livingMicrobeC,T,theta,air_filled_porosity,nitrate)
    ! Factor based on stoichiometry of denitrification; kgN/m2/yr
    denitrif_NO3_demand=sum(denitrif_Resp)*denitrif_NO3_factor

    if(denitrif_NO3_demand*dt>nitrate) then
        denitrif_Resp = denitrif_Resp*nitrate/(denitrif_NO3_demand*dt)
        denitrif_NO3_demand=nitrate/dt
    endif

    ! print *,air_filled_porosity,nitrate,denitrif_NO3_demand,sum(denitrif_Resp),sum(potential_tempResp)

    ! potential_tempResp = potential_tempResp + denitrif_Resp

    !Make sure it does not exceed available C
    where(dt*potential_tempResp > cohort%litterC)
        potential_tempResp=cohort%litterC/dt
    end where

!This needs to be changed if Vmax can be different for C vs nitrogen

if(soil_carbon_option == SOILC_CORPSE_N) then
    where(cohort%litterC>0)
        pot_tempN_decomposed=potential_tempResp*cohort%litterN/cohort%litterC !kgC/m2/yr
        pot_tempN_decomposed_denitrif=denitrif_Resp*cohort%litterN/cohort%litterC
    elsewhere
        pot_tempN_decomposed=0.0
        pot_tempN_decomposed_denitrif=0.0
    end where


    cohort%IMM_N_max=min((ammonium+nitrate)/dt-denitrif_NO3_demand,cohort%livingMicrobeC*(V_NH4(T)*ammonium+V_NO3(T)*nitrate)*(theta**3)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor))   !kg/m2/yr
    nitrogen_supply=sum(pot_tempN_decomposed*mup)
    nitrogen_supply_denitrif=sum(pot_tempN_decomposed_denitrif*mup)
    temp_N_microbes=cohort%livingMicrobeN
endif

    microbeTurnover=max(dfloat(0),(cohort%livingMicrobeC-minMicrobeC*sum(cohort%litterC))/Tmic)   !kg/m2/yr



    carbon_supply=sum(potential_tempResp*eup)
    carbon_supply_denitrif=sum(denitrif_Resp*eup)

    maintenance_resp=microbeTurnover*(1.0-et)


    !Update microbial biomass
    temp_C_microbes=cohort%livingMicrobeC

IF(soil_carbon_option == SOILC_CORPSE_N) THEN

carbon_supply = carbon_supply+carbon_supply_denitrif
nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

    if(carbon_supply - maintenance_resp > (nitrogen_supply+cohort%IMM_N_max)*CN_microb) THEN
        ! Growth is nitrogen limited, with not enough mineral N to support it with max immobilization
        N_LIM_STATE=N_LIMITED
        CN_imbalance_term = -cohort%IMM_N_max 

        ! Just skip denitrifaction in this case for now, since it probably doesn't amount to much if mineral N is limiting microbial growth
        ! Probably better to do this with implicit solution at some point :-(
        ! denitrif_Resp = 0.0
        ! denitrif_NO3_demand = 0.0

        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        if(N_limit_scheme==NLIM_OVERFLOW) THEN
            !!OPTION1: no impact on decomposition rate

            livemic_C_produced=dt*((nitrogen_supply-CN_imbalance_term)*CN_microb + maintenance_resp)
            livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)

            cohort%livingMicrobeN = cohort%livingMicrobeN + livemic_N_produced - dt*(microbeTurnover*et/CN_microb)
            cohort%livingMicrobeC = cohort%livingMicrobeC + livemic_C_produced - dt*(microbeTurnover)
            overflow_resp=carbon_supply - livemic_C_produced/dt


            tempResp=potential_tempResp + denitrif_resp !*N_inhibitory_factor  !Actual amount of carbon decomposed
            tempN_decomposed=pot_tempN_decomposed + pot_tempN_decomposed_denitrif !*N_inhibitory_factor  !Actual amount of nitrogen decomposed

            !print *,'overflow_resp',overflow_resp
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        elseif(N_limit_scheme==NLIM_DOWNREGULATE) THEN
            !!OPTION2: only change decomposition rate

            !!!!!!Inhibition factor
            N_inhibitory_factor=(CN_imbalance_term-(1-et)*microbeTurnover/CN_microb)/(nitrogen_supply-carbon_supply/CN_microb)

            !sum(mup(i)*cohort%litterN(i)/cohort%litterC(i)-eup(i)/CN_microb)
            tempResp=potential_tempResp *N_inhibitory_factor  !Actual amount of carbon decomposed
            tempN_decomposed=pot_tempN_decomposed *N_inhibitory_factor  !Actual amount of nitrogen decomposed


            !update carbon and nitrogen supply
            carbon_supply=sum(tempResp*eup)
            nitrogen_supply=sum(tempN_decomposed*mup)

            livemic_C_produced=dt*((nitrogen_supply-CN_imbalance_term)*CN_microb + maintenance_resp)
            livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)

            cohort%livingMicrobeN = cohort%livingMicrobeN + livemic_N_produced - dt*(microbeTurnover*et/CN_microb)
            cohort%livingMicrobeC = cohort%livingMicrobeC + livemic_C_produced - dt*(microbeTurnover)
            overflow_resp=carbon_supply - livemic_C_produced/dt

            livemic_C_produced=dt*(nitrogen_supply-CN_imbalance_term)
            livemic_N_produced=dt*(nitrogen_supply-CN_imbalance_term)/CN_microb

        else
            call error_mesg('update_cohort','Invalid N-limit_scheme',FATAL)

        endif


    elseif(carbon_supply - maintenance_resp >= (nitrogen_supply)*CN_microb) THEN
        ! Growth must be supported by immobilization of some mineral nitrogen, but is ultimately carbon limited
        N_LIM_STATE = IMMOBILIZATION

        ! carbon_supply = carbon_supply+carbon_supply_denitrif
        ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

        CN_imbalance_term = -((carbon_supply-maintenance_resp)/CN_microb - nitrogen_supply)
        cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
        cohort%livingMicrobeN = cohort%livingMicrobeN + dt*((carbon_supply-maintenance_resp)/CN_microb - microbeTurnover*et/CN_microb)

        livemic_C_produced=dt*carbon_supply
        livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb

        tempResp=potential_tempResp+denitrif_Resp ! Note, waste from denitrif still goes to CO2 !Actual amount of carbon decomposed
        tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif  !Actual amount of nitrogen decomposed
        overflow_resp=0

    elseif(carbon_supply>=maintenance_resp) THEN
        ! Growth is carbon limited -- extra N is mineralized
        N_LIM_STATE = EXCESS_N

        ! carbon_supply = carbon_supply+carbon_supply_denitrif
        ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

        cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
        cohort%livingMicrobeN = cohort%livingMicrobeN + dt*((carbon_supply-maintenance_resp)/CN_microb - microbeTurnover*et/CN_microb)
        CN_imbalance_term = nitrogen_supply - (carbon_supply-maintenance_resp)/CN_microb

        tempResp=potential_tempResp+denitrif_Resp  !Actual amount of carbon decomposed
        tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif  !Actual amount of nitrogen decomposed
        overflow_resp=0
        livemic_C_produced=dt*carbon_supply ! Note, waste from denitrif still goes to CO2
        livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb

    else
        ! Maintenance resp exceeds carbon supply. In this case, some additional biomass N will be lost
        N_LIM_STATE = EXCESS_N

        ! carbon_supply = carbon_supply+carbon_supply_denitrif
        ! nitrogen_supply = nitrogen_supply+nitrogen_supply_denitrif

        cohort%livingMicrobeC = cohort%livingMicrobeC + dt*(carbon_supply - microbeTurnover)
        cohort%livingMicrobeN = cohort%livingMicrobeN + dt*(carbon_supply/CN_microb - microbeTurnover/CN_microb)

        tempResp=potential_tempResp+denitrif_Resp ! Note, waste from denitrif still goes to CO2
        tempN_decomposed=pot_tempN_decomposed+pot_tempN_decomposed_denitrif
        overflow_resp=0.0
        CN_imbalance_term = nitrogen_supply-(carbon_supply-maintenance_resp)/CN_microb

        livemic_C_produced=dt*carbon_supply
        livemic_N_produced=dt*(carbon_supply-maintenance_resp)/CN_microb

    endif


    ! Enforce correct microbial C:N. Model has been having problems with slow increase in microbial C relative to N.
    !This feels a bit kloodgy but hopefully shouldn't cause problems
    if(cohort%livingMicrobeC/cohort%livingMicrobeN - CN_microb > 1e-3) then
        ! Too much microbial C. Respire extra C
        overflow_resp = overflow_resp + (cohort%livingMicrobeC - cohort%livingMicrobeN*CN_microb)
        cohort%livingMicrobeC = cohort%livingMicrobeC - (cohort%livingMicrobeC - cohort%livingMicrobeN*CN_microb)
    endif
    if(cohort%livingMicrobeC/cohort%livingMicrobeN - CN_microb < -1e-3) then
        ! Too much microbial N. Mineralize extra N
        CN_imbalance_term = CN_imbalance_term + (cohort%livingMicrobeN - cohort%livingMicrobeC/CN_microb)
        cohort%livingMicrobeN = cohort%livingMicrobeN - (cohort%livingMicrobeN - cohort%livingMicrobeC/CN_microb)
    endif



    !!Check for validity of C/N
    IF(cohort%livingMicrobeN<0) then

        print *,'et',et
        print *,'microbeTurnover',microbeTurnover*dt
        print *,'microbeTurnover_N',microbeTurnover*et/CN_microb*dt
        print *,'CN_imbalance_term',CN_imbalance_term
        print *,'N_LIM_STATE', N_LIM_STATE
        print *,'N supply',dt*nitrogen_supply
        print *,'livemic_N_produced',livemic_N_produced
        print *,'carbon_supply',carbon_supply
        print *,'maintenance_resp',maintenance_resp
        print *,'dN for live microb N',dt*(sum(mup*tempN_decomposed)-CN_imbalance_term-(microbeTurnover*et)/CN_microb)
        print *,'theta',theta
        print *,'T',T
        print *,'IMM_max',cohort%IMM_N_max
        print *,'ammonium',ammonium
        print *,'nitrate',nitrate
        print *,'Live microbe N',cohort%livingMicrobeN
        print *,'Immobilized inorganic N',cohort%IMM_N_gross*dt
        print *,'Mineralized organic N',cohort%MINER_gross*dt
        print *,'Denitrified NO3',denitrif_NO3_demand
        print *,'Denitrification resp',denitrif_Resp
        print *,'Previous microbe N',temp_N_microbes
        print *,'Previous microbe C',temp_C_microbes
        print *,'dt',dt
        print *,'Live microbe C',cohort%livingMicrobeC

        call print_cohort(cohort)
        call error_mesg('update_cohort','Microbe N < 0',FATAL)
    ENDIF


 if(cohort%livingMicrobeN>1d-8) then
    IF(abs((cohort%livingMicrobeC/cohort%livingMicrobeN)-CN_microb).ge.1d-5)THEN
        WRITE(*,*)'The fix C/N microbial ratio is not respected after the decomposition processes'
        write(*,*)'C/N',cohort%livingMicrobeC/cohort%livingMicrobeN
        call print_cohort(cohort)
        call error_mesg('update_cohort','Microbe C:N not preserved',FATAL)
    ENDIF
 endif

    IF(cohort%livingMicrobeC<0) then
        print *,'Live microbe C',cohort%livingMicrobeC
        print *,'Respired C',tempResp*dt
        print *,'microbe turnover',dt*microbeTurnover
        print *,'Previous microbe C',temp_C_microbes
        print *,'dt',dt
        call print_cohort(cohort)
        call error_mesg('update_cohort','Microbe C < 0',FATAL)
    ENDIF

    deadmic_C_produced=dt*microbeTurnover*et
    cohort%litterC(3)=cohort%litterC(3)+deadmic_C_produced!kg/m2

    deadmic_N_produced=dt*microbeTurnover*et/CN_microb!xz
    cohort%litterN(3)=cohort%litterN(3)+deadmic_N_produced!xz  !kg/m2


    IF(CN_imbalance_term.ge.dfloat(0))THEN
        cohort%IMM_N_gross=dfloat(0)
        cohort%MINER_gross=sum((1-mup)*tempN_decomposed)+CN_imbalance_term
    ELSE
        cohort%IMM_N_gross=-CN_imbalance_term
        cohort%MINER_gross=sum((1-mup)*tempN_decomposed)
    ENDIF


    if(cohort%IMM_N_gross<0.0 .OR. cohort%MINER_gross<0.0) then
         print *,'Immob',cohort%IMM_N_gross
         print *,'Mineralization',cohort%MINER_gross

        print *,'et',et
        print *,'microbeTurnover',microbeTurnover*dt
        print *,'microbeTurnover_N',microbeTurnover*et/CN_microb*dt
        print *,'CN_imbalance_term',CN_imbalance_term
        print *,'N_LIM_STATE', N_LIM_STATE
        print *,'N supply',dt*nitrogen_supply
        print *,'livemic_N_produced',livemic_N_produced
        print *,'carbon_supply',carbon_supply
        print *,'maintenance_resp',maintenance_resp
        print *,'dN for live microb N',dt*(sum(mup*tempN_decomposed)-CN_imbalance_term-(microbeTurnover*et)/CN_microb)
        print *,'theta',theta
        print *,'T',T
        print *,'IMM_max',cohort%IMM_N_max
        print *,'ammonium',ammonium

        print *,'nitrate',nitrate
        print *,'Live microbe N',cohort%livingMicrobeN
        print *,'Immobilized inorganic N',cohort%IMM_N_gross*dt
        print *,'Mineralized organic N',cohort%MINER_gross*dt
        print *,'Previous microbe N',temp_N_microbes
        print *,'Previous microbe C',temp_C_microbes
        print *,'dt',dt
        print *,'Live microbe C',cohort%livingMicrobeC

        call print_cohort(cohort)
        call error_mesg('update_cohort','N Min < 0 or N immob < 0',FATAL)
    endif

    ! This includes denitrification resp added above
    CO2prod=dt*(sum(tempResp*(1.0-eup))+microbeTurnover*(1.0-et)+overflow_resp) !kg/m2
    ! This includes denitrification resp added above
    cohort%litterC=cohort%litterC-dt*tempResp     !kg/m2




    !-----update quantity of available nitrate and ammonium in soil -----------------------------------------
    if(.NOT. denitrif_first_order)  nitrate = nitrate - denitrif_NO3_demand*dt

    IF((V_NH4(T)*ammonium+V_NO3(T)*nitrate).gt.dfloat(0))THEN
        nitrate=nitrate+min(CN_imbalance_term,dfloat(0))*(V_NO3(T)*(nitrate)/(V_NH4(T)*ammonium+V_NO3(T)*nitrate))*dt
        ammonium=ammonium+max(CN_imbalance_term,dfloat(0))*dt+min(CN_imbalance_term,dfloat(0))*dt*(V_NH4(T)*(ammonium)/(V_NH4(T)*ammonium+V_NO3(T)*nitrate))+sum((1-mup)*tempN_decomposed)*dt
    ELSE
        nitrate=nitrate+(min(CN_imbalance_term,dfloat(0))/2)*dt
        ammonium=ammonium+max(CN_imbalance_term,dfloat(0))*dt+min(CN_imbalance_term,dfloat(0))/2*dt+(sum((1-mup)*tempN_decomposed))*dt
    ENDIF

    ELSE ! if not SOILC_CORPSE_N
        N_LIM_STATE = N_LIM_TURNED_OFF
        tempResp=potential_tempResp
        !C-only model order of operations was remove decomposed litter first
        where(dt*tempResp > cohort%litterC)
            tempResp=cohort%litterC/dt
            cohort%litterC=0.0
        elsewhere
            cohort%litterC=cohort%litterC-dt*tempResp
        end where
        !Update microbial biomass
        temp_C_microbes=cohort%livingMicrobeC
        microbeTurnover=max(0.0,(cohort%livingMicrobeC-minMicrobeC*sum(cohort%litterC))/Tmic)
        cohort%livingMicrobeC=cohort%livingMicrobeC + dt*(sum(eup*tempResp) - microbeTurnover)
        livemic_C_produced=dt*(sum(eup*tempResp))
        deadmic_C_produced=dt*microbeTurnover*et
        cohort%litterC(3)=cohort%litterC(3)+deadmic_C_produced

        CO2prod=dt*(sum(tempResp*(1.0-eup))+microbeTurnover*(1.0-et))

        IF(cohort%livingMicrobeC<0) then
            print *,'Live microbe C',cohort%livingMicrobeC
            print *,'Respired C',tempResp*dt
            print *,'microbe turnover',dt*microbeTurnover
            print *,'Previous microbe C',temp_C_microbes
            print *,'dt',dt
            call print_cohort(cohort)
            call error_mesg('update_cohort','Microbe C < 0',FATAL)
        ENDIF

        tempN_decomposed = 0.0
        cohort%IMM_N_gross=0.0
        cohort%MINER_gross=0.0
        deadmic_N_produced=0.0
        livemic_N_produced=0.0
        denitrif_NO3_demand=0.0

    ENDIF

    ! Update the amount of organic C and N in the cohort after the decomposition process

    ! Removal of C from cohort done above to preserve correct order of operations
    ! cohort%litterC=cohort%litterC-dt*tempResp     !kg/m2
    totalResp=totalResp+tempResp                  !kg/m2/yr

    cohort%litterN=cohort%litterN-dt*tempN_decomposed     !kg/m2
    totalN_decomposed=totalN_decomposed+tempN_decomposed   !kg/m2/yr

    IMM_Nprod=cohort%IMM_N_gross*dt  		!kg/m2	!Gross immobilization of inorganic nitrogen for the cohort
    MINERAL_prod=cohort%MINER_gross*dt		!kg/m2	!Gross mineralization of organic nitrogen for the cohort

    cohort%MINER_prod=cohort%MINER_prod+cohort%MINER_gross*dt
    cohort%IMM_Nprod=cohort%IMM_Nprod+cohort%IMM_N_gross*dt


    cohort%CO2=cohort%CO2+CO2prod

    cohort%Rtot=cohort%Rtot+sum(totalResp)

    denitrif = denitrif_NO3_demand

    if(.NOT. check_cohort(cohort)) THEN
       call print_cohort(cohort)
       print *,'N limitation type',N_LIM_STATE
       print *,'CO2 produced',CO2prod
       print *,'Overflow resp',overflow_resp*dt
       print *,'CN imbalance',CN_imbalance_term*dt
       print *,'C supply',carbon_supply*dt
       print *,'N supply',nitrogen_supply*dt
       print *,'Microbe C prod',livemic_C_produced
       print *,'Microbe N prod',livemic_N_produced
       print *,'Dead mic C prod',deadmic_C_produced
       print *,'Dead mic N prod',deadmic_N_produced
       print *,'Maintenance resp',maintenance_resp*dt
       print *,'Uptake resp',totalResp*(1.0-eup)*dt
       print *,'Denitrif',denitrif_NO3_demand
       print *,'Cohort C - required total',cohortCSum(cohort)-cohort%originalLitterC
       print *,'Nitrate',nitrate
       call error_mesg('update_cohort','Cohort invalid',FATAL)
    endif


    !Update protected carbon
    protectedCturnover = cohort%protectedC/tProtected

    IF(sum(cohort%litterC).gt.0.0 .and. cohortVolume.gt.0.0) THEN
        !Change: divide by volume instead of litter C. Keeps it linear with size, but allows dependence on unprotected C
        if (microbe_driven_protection) then
            newProtectedC(:) = protection_rate*cohort%livingMicrobeC/cohortVolume*cohort%litterC(:)*dt
        else
            newProtectedC(:) = protection_rate*cohort%litterC(:)*dt
        endif
    ELSE
        newProtectedC = 0.0
    ENDIF
    where(newProtectedC.gt.cohort%litterC) newProtectedC=cohort%litterC
    cohort%protectedC = cohort%protectedC + newProtectedC - dt*protectedCturnover
    cohort%litterC = cohort%litterC - newProtectedC + dt*protectedCturnover

    protected_produced=newProtectedC
    protected_turnover_rate=protectedCturnover


IF(soil_carbon_option == SOILC_CORPSE_N) THEN
    protectedNturnover = cohort%protectedN/tProtected_N  !xz
    IF(sum(cohort%litterN).gt.0.0 .and. cohortVolume.gt.0.0) THEN
        !Change: divide by volume instead of litter C. Keeps it linear with size, but allows dependence on unprotected C
        if (microbe_driven_protection) then
            newProtectedN(:) = protection_rate*cohort%livingMicrobeC/cohortVolume*cohort%litterN(:)*dt
        else
            newProtectedN(:) = protection_rate*cohort%litterN(:)*dt
        endif
    ELSE
        newProtectedN = 0.0
    ENDIF
    where(newProtectedN.gt.cohort%litterN) newProtectedN=cohort%litterN
    cohort%protectedN = cohort%protectedN + newProtectedN - dt*protectedNturnover
    cohort%litterN = cohort%litterN - newProtectedN + dt*protectedNturnover

    protected_N_produced=newProtectedN  ! kg/m2
    protected_N_turnover_rate=protectedNturnover  ! kg/m2/year
ELSE
    protected_N_produced=0.0
    protected_N_turnover_rate=0.0
ENDIF

end subroutine update_cohort





! COPIED FROM VEGN_DYNAMICS
! ============================================================================
! The combined reduction in decomposition rate as a funciton of TEMP and MOIST
! Based on CENTURY Parton et al 1993 GBC 7(4):785-809 and Bolker's copy of
! CENTURY code
elemental function A_function(soilt, theta) result(A)
  real :: A                 ! return value, resulting reduction in decomposition rate
  real, intent(in) :: soilt ! effective temperature for soil carbon decomposition
  real, intent(in) :: theta

  real :: soil_temp; ! temperature of the soil, deg C
  real :: Td; ! rate multiplier due to temp
  real :: Wd; ! rate reduction due to mositure

  ! coefficeints and terms used in temperaturex term
  real :: Topt,Tmax,t1,t2,tshl,tshr;

  soil_temp = soilt-273.16;

  ! EFFECT OF TEMPERATURE
  ! from Bolker's century code
  Tmax=45.0;
  if (soil_temp > Tmax) soil_temp = Tmax;
  Topt=35.0;
  tshr=0.2; tshl=2.63;
  t1=(Tmax-soil_temp)/(Tmax-Topt);
  t2=exp((tshr/tshl)*(1.-t1**tshl));
  Td=t1**tshr*t2;

  if (soil_temp > -10) Td=Td+0.05;
  if (Td > 1.) Td=1.;

  ! EFFECT OF MOISTURE
  ! Linn and Doran, 1984, Soil Sci. Amer. J. 48:1267-1272
  ! This differs from the Century Wd
  ! was modified by slm/ens based on the figures from the above paper
  !     (not the reported function)

  if(theta <= 0.3) then
     Wd = 0.2;
  else if(theta <= 0.6) then
     Wd = 0.2+0.8*(theta-0.3)/0.3;
  else
     Wd = exp(2.3*(0.6-theta));
  endif

  A = (Td*Wd); ! the combined (multiplicative) effect of temp and water
               ! on decomposition rates
end function A_function


pure subroutine initializeCohort(cohort,litterInputC,litterInputN,initialMicrobeC,initialMicrobeN,initialProtectedC,initialProtectedN,multiplier,CO2)
    type(litterCohort),intent(out)::cohort
    real,intent(in),optional::litterInputC(n_c_types),litterInputN(n_c_types),CO2
    real,intent(in),optional::multiplier
    real,intent(in),optional::initialMicrobeC,initialMicrobeN
    real,intent(in),optional::initialProtectedC(n_c_types),initialProtectedN(n_c_types)

    real::litterInputCval(n_c_types),litterInputNval(n_c_types)
    real::initialMicrobeCval,initialMicrobeNval,CO2val,multiplierval
    real::initialProtectedCval(n_c_types),initialProtectedNval(n_c_types)

    litterInputCval=0.0
    litterInputNval=0.0
    initialProtectedCval=0.0
    initialProtectedNval=0.0
    initialMicrobeCval=0.0
    initialMicrobeNval=0.0
    CO2val=0.0
    multiplierval=1.0

    if (present(litterInputC)) litterInputCval=litterInputC
    if (present(litterInputN)) litterInputNval=litterInputN
    if (present(initialprotectedC)) initialProtectedCval=initialProtectedC
    if (present(initialprotectedN)) initialProtectedNval=initialProtectedN
    if (present(initialMicrobeC)) initialMicrobeCval=initialMicrobeC

    !Should we make sure microbe C:N is correct?
    if (present(initialMicrobeN)) initialMicrobeNval=initialMicrobeN
    if (present(CO2)) CO2val=CO2
    if (present(multiplier)) multiplierval=multiplier


    !originalLitterC is there to check carbon conservation
    cohort%originalLitterC=(sum(litterInputCval)+CO2val+initialMicrobeCval+sum(initialProtectedCval))*multiplierval
    cohort%litterC=litterInputCval*multiplierval
    cohort%protectedC=initialProtectedCval*multiplierval
    cohort%livingMicrobeC=initialMicrobeCval*multiplierval
    cohort%CO2=CO2val*multiplierval
    cohort%Rtot=0.0

    cohort%originalLitterN=(sum(litterInputNval)+initialMicrobeNval+sum(initialProtectedNval))*multiplierval
    cohort%litterN=litterInputNval*multiplierval
    cohort%protectedN=initialProtectedNval*multiplierval
    cohort%livingMicrobeN=initialMicrobeNval*multiplierval

    cohort%MINER_prod=0.0
    cohort%IMM_Nprod=0.0
    cohort%MINER_gross=0.0
    cohort%IMM_N_gross=0.0
    cohort%IMM_N_max=0.0

end subroutine initializeCohort


pure function Resp(Ctotal,Chet,T,theta,air_filled_porosity)
    real,intent(in)::Chet                       !heterotrophic (microbial) C
    real,intent(in)::T,theta                    !temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity        !Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in),dimension(n_c_types)::Ctotal !Substrate C
    real,dimension(n_c_types)::Resp,tempresp
    real::enz,Cavail(n_c_types)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    !Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp=0.0
        return
    ENDIF

    Resp=Vmax(T)*theta**3*(Cavail)*enz/(sum(Cavail)*kC+enz)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor*aerobic_max)


end function Resp



pure function Resp_denitrif(Ctotal,Chet,T,theta,air_filled_porosity,nitrate)
    real,intent(in)::Chet                       !heterotrophic (microbial) C
    real,intent(in)::T,theta                    !temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity        !Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in),dimension(n_c_types)::Ctotal !Substrate C
    real,intent(in)::nitrate                     !Available nitrate
    real,dimension(n_c_types)::Resp_denitrif,tempresp
    real::denitrif_NO3_demand
    real::enz,Cavail(n_c_types)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    !Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp_denitrif=0.0
        return
    ENDIF

    tempresp=Vmax_denitrif(T)*(Cavail)*enz/(sum(Cavail)*kC+enz)*theta**3*max(0.0,(denitrif_theta_min-air_filled_porosity**gas_diffusion_exp))*aerobic_max

    ! Actual denitrification rate as limited by NO3 concentration; kgN/m2/yr
    ! k_denitrif relates demand (rate) to NO3 pool for rate limitation
    denitrif_NO3_demand=sum(tempresp)*denitrif_NO3_factor

    if(nitrate>0.0) then
      Resp_denitrif = tempresp * nitrate/(nitrate + k_denitrif*denitrif_NO3_demand)
    else
      resp_denitrif = 0.0
    endif



end function Resp_denitrif


pure function Resp_myc(Ctotal,Chet,T,theta,air_filled_porosity)
    real,intent(in)::Chet                       !heterotrophic (microbial) C
    real,intent(in)::T,theta                    !temperature (k), theta (fraction of 1.0)
    real,intent(in)::air_filled_porosity        !Fraction of 1.0.  Different from theta since it includes ice
    real,intent(in),dimension(n_c_types)::Ctotal !Substrate C
    real,dimension(n_c_types)::Resp_myc,tempresp
    real::enz,Cavail(n_c_types)
    real, parameter :: aerobic_max = 0.022 ! Maximum soil-moisture factor under ideal conditions



    enz=Chet*enzfrac

    !Good place to implement DAMM functionality: Available carbon is the amount that diffuses to enzyme site
    Cavail=Ctotal
    IF(sum(Cavail).eq.0.0 .OR. theta.eq.0.0 .OR. enz.eq.0.0) THEN
        Resp_myc=0.0
        return
    ENDIF

    Resp_myc=Vmax_myc(T)*theta**3*(Cavail)*enz/(sum(Cavail)*k_myc_decomp+enz)*max((air_filled_porosity)**gas_diffusion_exp,min_anaerobic_resp_factor*aerobic_max)

    !ox_avail=oxygen_concentration(Ox,sum(tempresp)/sum(Cavail)*theta*oxPerC)
    !print *,sum(tempresp)/sum(Cavail)
    !print *,ox_avail/(kO+ox_avail)
    !print *,tempresp*(1.0-theta)+theta*tempresp*ox_avail/(kO+ox_avail)

    !Assumes pores are either saturated or not oxygen limited, divided according to theta
    !Resp=tempresp*(1.0-theta)+theta*tempresp*ox_avail/(kO+ox_avail)
end function Resp_myc


pure function Vmax(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(n_c_types)::alpha,Vmax

    alpha=vmaxref/exp(-Ea/(Rugas*Tref))
    Vmax=alpha*exp(-Ea/(Rugas*T))
end function Vmax

pure function Vmax_denitrif(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(n_c_types)::alpha,Vmax_denitrif

    alpha=vmaxref_denitrif/exp(-Ea/(Rugas*Tref))
    Vmax_denitrif=alpha*exp(-Ea/(Rugas*T))
end function Vmax_denitrif

pure function Vmax_myc(T)
    real,intent(in)::T
    real,parameter::Tref=293.15
    real,dimension(n_c_types)::alpha,Vmax_myc

    alpha=vmaxref_myc_decomp/exp(-Ea/(Rugas*Tref))
    Vmax_myc=alpha*exp(-Ea/(Rugas*T))
end function Vmax_myc




! Calculates the rate of [Arbuscular] mycorrhizal uptake of mineral N in the pool.
! This is a function of mycorrhizal biomass concentration and mineral N in the layer
pure subroutine mycorrhizal_mineral_N_uptake_rate(pool,myc_biomass,layer_thickness,nitrate_uptake,ammonium_uptake)
  type(soil_pool),intent(in)::pool
  real,intent(in)::myc_biomass             ! (kgC/m2)
  real,intent(in)::layer_thickness         ! (m)
  real,intent(out)::nitrate_uptake         ! (kgN/m2/year)
  real,intent(out)::ammonium_uptake        ! (kgN/m2/year)


  ! This is a Michaelis-Menton function of mycorrhizal biomass concentration and total mineral N
  nitrate_uptake = pool%nitrate*Vmax_myc_min_N_uptk*&
          (myc_biomass/layer_thickness)/(k_myc_min_N_uptk+myc_biomass/layer_thickness)
  ammonium_uptake = pool%ammonium*Vmax_myc_min_N_uptk*&
          (myc_biomass/layer_thickness)/(k_myc_min_N_uptk+myc_biomass/layer_thickness)

end subroutine mycorrhizal_mineral_N_uptake_rate

! Calculates rate of N mineralization from miner (ecto) mycorrhizae, WITHOUT changing any pools
 subroutine hypothetical_mycorrhizal_decomposition(pool,myc_biomass,T,theta,air_filled_porosity,N_uptake,C_uptake,CO2prod,dt)
  type(soil_pool),intent(in)::pool
  real,intent(in)::myc_biomass,dt,T,theta,air_filled_porosity
  real,intent(out)::N_uptake,C_uptake,CO2prod

  integer::nn
  real :: cohort_myc_biomass  ! Distribute among cohorts
  real :: totalCarbon, weight, potential_tempResp(n_c_types), pot_tempN_decomposed(n_c_types)

  N_uptake = 0.0
  C_uptake = 0.0
  CO2prod = 0.0

  call poolTotals(pool,totalCarbon=totalCarbon)

  do nn=1,pool%n_cohorts

    ! Weight myc biomass by cohort size
    IF(totalCarbon.gt.0) THEN
       weight=cohortCsum(pool%litterCohorts(nn),only_active=.TRUE.)/totalCarbon
    ELSE
       weight=1.0
    ENDIF

    cohort_myc_biomass = myc_biomass*weight

    potential_tempResp=Resp_myc(pool%litterCohorts(nn)%litterC,cohort_myc_biomass,T,theta,air_filled_porosity)

    !Make sure it does not exceed available C
    where(dt*potential_tempResp > pool%litterCohorts(nn)%litterC)
        potential_tempResp=pool%litterCohorts(nn)%litterC/dt
    end where

    where(pool%litterCohorts(nn)%litterC>0)
        pot_tempN_decomposed=potential_tempResp*pool%litterCohorts(nn)%litterN/pool%litterCohorts(nn)%litterC !kgC/m2/yr
    elsewhere
        pot_tempN_decomposed=0.0
    end where

    C_uptake = C_uptake + sum(potential_tempResp*eup)*dt
    N_uptake = N_uptake + sum(pot_tempN_decomposed)*dt
    CO2prod = CO2prod + sum(potential_tempResp*(1-eup))*dt

  enddo

end subroutine hypothetical_mycorrhizal_decomposition


! Calculates rate of N mineralization from miner (ecto) mycorrhizae, WITH changing pools
subroutine mycorrhizal_decomposition(pool,myc_biomass,T,theta,air_filled_porosity,N_uptake,C_uptake,CO2prod,dt)
  type(soil_pool),intent(inout)::pool
  real,intent(in)::myc_biomass,dt,T,theta,air_filled_porosity
  real,intent(out)::N_uptake,C_uptake,CO2prod

  integer::nn
  real :: cohort_myc_biomass  ! Distribute among cohorts
  real :: totalCarbon, weight, potential_tempResp(n_c_types), pot_tempN_decomposed(n_c_types)

  N_uptake = 0.0
  C_uptake = 0.0
  CO2prod = 0.0

  call poolTotals(pool,totalCarbon=totalCarbon)

  do nn=1,pool%n_cohorts

    ! Weight myc biomass by cohort size
    IF(totalCarbon.gt.0) THEN
       weight=cohortCsum(pool%litterCohorts(nn),only_active=.TRUE.)/totalCarbon
    ELSE
       weight=1.0
    ENDIF

    cohort_myc_biomass = myc_biomass*weight

    potential_tempResp=Resp_myc(pool%litterCohorts(nn)%litterC,cohort_myc_biomass,T,theta,air_filled_porosity)

    !Make sure it does not exceed available C
    where(dt*potential_tempResp > pool%litterCohorts(nn)%litterC)
        potential_tempResp=pool%litterCohorts(nn)%litterC/dt
    end where

    where(pool%litterCohorts(nn)%litterC>0)
        pot_tempN_decomposed=potential_tempResp*pool%litterCohorts(nn)%litterN/pool%litterCohorts(nn)%litterC !kgC/m2/yr
    elsewhere
        pot_tempN_decomposed=0.0
    end where

    C_uptake = C_uptake + sum(potential_tempResp*eup_myc)*dt
    N_uptake = N_uptake + sum(pot_tempN_decomposed)*dt
    CO2prod = CO2prod + sum(potential_tempResp*(1-eup_myc))*dt

    pool%litterCohorts(nn)%litterC = pool%litterCohorts(nn)%litterC - potential_tempResp*dt
    pool%litterCohorts(nn)%litterN = pool%litterCohorts(nn)%litterN - pot_tempN_decomposed*dt
    pool%litterCohorts(nn)%originalLitterC = pool%litterCohorts(nn)%originalLitterC - sum(potential_tempResp*eup_myc)*dt
    pool%litterCohorts(nn)%originalLitterN = pool%litterCohorts(nn)%originalLitterN - sum(pot_tempN_decomposed)*dt
    pool%litterCohorts(nn)%CO2 = pool%litterCohorts(nn)%CO2 + sum(potential_tempResp*(1-eup_myc))*dt

  enddo

end subroutine mycorrhizal_decomposition

! =============================================================================
! prints on-line state of the carbon cohort
subroutine debug_cohort(c)
   type(litterCohort), intent(in) :: c
   __DEBUG___(c%litterC)
   __DEBUG___(c%protectedC)
   __DEBUG___(c%livingMicrobeC)
   __DEBUG___(c%CO2)
   __DEBUG___(c%originalLitterC)

   __DEBUG___(c%litterN)
   __DEBUG___(c%protectedN)
   __DEBUG___(c%livingMicrobeN)
   __DEBUG___(c%originalLitterN)
   write(*,*)
end subroutine debug_cohort

! =============================================================================
! Add nitrogen stuff to this?
subroutine debug_pool(p,tag)
   type(soil_pool), intent(in) :: p
   character(*), intent(in) :: tag

   integer :: i
   write(*,'(x,a)',advance='NO')trim(tag)
   __DEBUG5__(p%max_cohorts,p%n_cohorts,p%protection_rate,p%Qmax,p%dissolved_carbon)
!   do i = 1, p%n_cohorts
!      write(*,'(x,i3.3)',advance='NO')i
!      call debug_cohort(p%litterCohorts(i))
!   enddo
end subroutine debug_pool


subroutine print_cohort(cohort)
    type(litterCohort)::cohort

    WRITE (*,*),'----------------'
    WRITE (*,*),'Original C =',cohort%originalLitterC
    WRITE (*,*),'Unprotected C=',cohort%litterC
    WRITE (*,*),'Living microbial C =',cohort%livingMicrobeC
    WRITE (*,*),'Protected C =',cohort%protectedC

    WRITE (*,*),'CO2 =',cohort%CO2
    WRITE (*,*),'Rtot =',cohort%Rtot
    WRITE (*,*),'Sum of carbon =',cohortCsum(cohort)
    WRITE (*,*),'----------------'

    WRITE (*,*),'----------------'
    WRITE (*,*),'Original N =',cohort%originalLitterN
    WRITE (*,*),'Unprotected N=',cohort%litterN
    WRITE (*,*),'Living microbial N =',cohort%livingMicrobeN
    WRITE (*,*),'Protected N =',cohort%protectedN

    WRITE (*,*),'gross miner =',cohort%MINER_prod
    WRITE (*,*),'gross Immobil =',cohort%IMM_Nprod
    WRITE (*,*),'last miner =',cohort%MINER_gross
    WRITE (*,*),'last immob =',cohort%IMM_N_gross
    WRITE (*,*),'Sum of nitrogen =',cohortNsum(cohort)

    if(cohort%livingMicrobeN>0) WRITE(*,*), 'Microbe C:N =',cohort%livingMicrobeC/cohort%livingMicrobeN
end subroutine


!Check for carbon balance and invalid values
 logical function check_cohort(cohort) result(cohortGood)
    type(litterCohort),intent(in)::cohort
    integer::n
    logical:: tempGood
    real :: cohortC
    real :: cohortN
    ! ZMS
    real,parameter :: tol_roundoff = 1.e-11    ![kg C/m^2] tolerance for roundoff error in soil carbon numerics

    cohortGood=.NOT. ( &
     (min(cohort%originalLitterC,cohort%livingMicrobeC,cohort%CO2,cohort%livingMicrobeN).lt.-tol_roundoff) .OR. &
    isNAN(cohort%originalLitterC) .OR. &
    isNAN(cohort%livingMicrobeC) .OR. &
    isNAN(cohort%CO2)  .OR. &
    (min(cohort%originalLitterN,cohort%livingMicrobeN).lt.0) .OR. &
    isNAN(cohort%originalLitterN) .OR. &
    isNAN(cohort%livingMicrobeN) &
    )

   cohortC=cohortCSum(cohort)
  !if(cohortC .GT. 0.0) cohortGood = cohortGood .AND. (abs(cohortC-cohort%originalLitterC)/cohortC) .LT. tol
  ! ZMS Make this an either relative or absolute balance check to allow roundoff error for infinitessimal pools in deep layers
    if(cohortC .GT. 0.0) cohortGood = cohortGood .AND. &
              (abs(cohortC-cohort%originalLitterC)/cohortC .LT. tol .OR. abs(cohortC-cohort%originalLitterC) .LT. tol_roundoff)

    DO n=1,n_c_types
        tempGood = .NOT. ( &
        (cohort%litterC(n).lt.0) .OR. &
        (cohort%protectedC(n).lt.0) .OR. &
        (cohort%litterN(n).lt.0) .OR. &
        (cohort%protectedN(n).lt.0) .OR. &
        (isNAN(cohort%litterC(n))) .OR. &
        (isNAN(cohort%protectedC(n)))  .OR. &
        (isNAN(cohort%litterN(n))) .OR. &
        (isNAN(cohort%protectedN(n)))  &
        )
        cohortGood=cohortGood .AND. tempGood
    ENDDO


    cohortGood = cohortGood .AND. (cohort%IMM_N_gross>=0) .AND. (cohort%MINER_gross>=0)

    ! IF(.NOT. cohortGood) THEN
    !     WRITE (*,*)'Cohort carbon pool error:'
    !     call print_cohort(cohort)
    !     WRITE (*,*)'Sum =',cohortCSum(cohort),'Difference =',cohortCSum(cohort)-(cohort%originalLitterC)
    !    call error_mesg('Dsdt','Found bad cohort in fineWood litter',FATAL)
    !  ENDIF


 if(cohort%livingMicrobeN>0) then
    IF(abs((cohort%livingMicrobeC/cohort%livingMicrobeN)-CN_microb).ge.1d-1)THEN
      cohortGood = .FALSE.
    ENDIF
 endif


end function check_cohort



 function cohortCSum(cohort,only_active)
    type(litterCohort),intent(in)::cohort
    logical,intent(in),optional::only_active
    real::tempSum
    real::cohortCSum

    logical::only_act

    only_act=.FALSE.
    if(present(only_active)) only_act=only_active


    tempSum=0.0
    tempSum=tempSum+cohort%livingMicrobeC
    tempSum=tempSum+sum(cohort%litterC)
    tempSum=tempSum+sum(cohort%protectedC)
    !tempSum=tempSum+sum(cohort%minC)
    if (.NOT. only_act) then
        tempSum=tempSum+cohort%CO2
    endif
    cohortCSum=tempSum
END FUNCTION

 function cohortNSum(cohort,only_active)
    type(litterCohort),intent(in)::cohort
    logical,intent(in),optional::only_active
    real*8::tempSum
    real*8::cohortNSum

    logical::only_act

    only_act=.FALSE.
    if(present(only_active)) only_act=only_active

    tempSum=dfloat(0)
    tempSum=tempSum+cohort%livingMicrobeN
    tempSum=tempSum+sum(cohort%litterN)
    tempSum=tempSum+sum(cohort%protectedN)
  !  tempSum=tempSum+(cohort%MINER_gross-cohort%IMM_N_gross)
    if(only_act) then
      tempSum=tempSum+(cohort%MINER_prod-cohort%IMM_Nprod)
    endif

    cohortNSum=tempSum
END FUNCTION


!Add a cohort to the soil carbon pool
subroutine add_cohort(pool,newCohort)
    type(soil_pool),intent(inout) :: pool
    type(litterCohort),intent(in) :: newCohort

    type(litterCohort),allocatable::newCohorts(:)

    if (.not.allocated(pool%litterCohorts)) then
       allocate(pool%litterCohorts(init_n_cohorts))
       pool%n_cohorts = 0
    endif

    if (pool%n_cohorts+1>size(pool%litterCohorts)) then
       ! not enough room for new cohort in the array of cohorts, reallocate
       ! cohort array: double its size
       allocate(newCohorts(2*size(pool%litterCohorts)))
       newCohorts(1:pool%n_cohorts) = pool%litterCohorts(1:pool%n_cohorts)
       call move_alloc(from=newCohorts,to=pool%litterCohorts)
    endif

    pool%litterCohorts(pool%n_cohorts+1) = newCohort
    pool%n_cohorts = pool%n_cohorts+1
end subroutine add_cohort


!Adds litter as a new cohort
subroutine add_litter(pool,newLitterC,newLitterN,rhizosphere_frac)
    type(soil_pool),intent(inout)::pool
    real,intent(in) :: newLitterC(n_c_types),newLitterN(n_c_types)
    real,intent(in),optional :: rhizosphere_frac

    type(litterCohort)::newCohort,tempCohort
    real::initialMicrobeC,initialMicrobeN
    real::rhiz_frac

    rhiz_frac=1.0
    if(present(rhizosphere_frac)) rhiz_frac=max(0.0,min(1.0,rhizosphere_frac))

    if(any(newLitterC < 0.0)) call error_mesg('add_litter','Some of new litter C less than zero',FATAL)
    if(any(newLitterN < 0.0)) call error_mesg('add_litter','Some of new litter N less than zero',FATAL)


    initialMicrobeC=sum(newLitterC*minMicrobeC)
    ! More important to conserve N, or to make sure there is some initial microbial biomass?
    ! We could just assume enough fixers to ensure some minimal initial biomass?
    if(soil_carbon_option == SOILC_CORPSE_N) THEN
        initialMicrobeN=initialMicrobeC/CN_microb
    ELSE
        initialMicrobeN=0.0
    ENDIF

    if (.NOT. use_rhizosphere_cohort) then
        call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),initialMicrobeC=initialMicrobeC,&
                                        litterInputN=newLitterN*(1.0-minMicrobeC),initialMicrobeN=initialMicrobeN)
        call add_cohort(pool,newCohort)
    else
        !First make sure there are enough cohorts in pool
        DO WHILE (pool%n_cohorts<max(BULK,RHIZ))
            call initializeCohort(newCohort)
            call add_cohort(pool,newCohort)
        ENDDO

        !Add rhizosphere fraction
        call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),initialMicrobeC=initialMicrobeC,&
                litterInputN=newLitterN*(1.0-minMicrobeC),initialMicrobeN=initialMicrobeN,multiplier=rhiz_frac)
        call combine_cohorts(newCohort,pool%litterCohorts(RHIZ),tempCohort)
        pool%litterCohorts(RHIZ)=tempCohort


        !Add bulk soil fraction
        call initializeCohort(newCohort,litterInputC=newLitterC*(1.0-minMicrobeC),initialMicrobeC=initialMicrobeC,&
                litterInputN=newLitterN*(1.0-minMicrobeC),initialMicrobeN=initialMicrobeN,multiplier=1.0-rhiz_frac)
        call combine_cohorts(newCohort,pool%litterCohorts(BULK),tempCohort)
        pool%litterCohorts(BULK)=tempCohort

    endif


end subroutine add_litter

!Add carbon to all cohorts in pool, weighted by cohort size.
!For leaching or exudation that is spread evenly in soil instead of new cohort
subroutine add_C_N_to_cohorts(pool,litterC,protectedC,livingMicrobeC,CO2,litterN,protectedN,livingMicrobeN)
    type(soil_pool),intent(inout)::pool
    real,optional,dimension(n_c_types),intent(in)::litterC,protectedC,litterN,protectedN
    real,optional,intent(in)::livingMicrobeC,CO2,livingMicrobeN

    real,dimension(n_c_types)::litterCval,protectedCval,litterNval,protectedNval
    real::livingMicrobeCval,CO2val,livingMicrobeNval
    real::totalCarbon,weight
    integer::ii

    livingMicrobeCval=0.0
    protectedCval=0.0
    litterCval=0.0
    CO2val=0.0

    livingMicrobeNval=0.0
    protectedNval=0.0
    litterNval=0.0

    IF (present(litterC)) litterCval=litterC
    IF (present(protectedC)) protectedCval=protectedC
    IF (present(livingMicrobeC)) livingMicrobeCval=livingMicrobeC
    IF (present(CO2)) CO2val=CO2

    IF (present(litterN)) litterNval=litterN
    IF (present(protectedN)) protectedNval=protectedN
    IF (present(livingMicrobeN)) livingMicrobeNval=livingMicrobeN

    IF (any(litterCval<0) .or. any(protectedCval<0) .or. livingMicrobeCval<0 .or. CO2val<0) &
          call error_mesg('add_carbon_to_cohorts','Carbon added less than zero',FATAL)
    IF (any(litterNval<0) .or. any(protectedNval<0) .or. livingMicrobeNval<0) &
        call error_mesg('add_carbon_to_cohorts','Nitrogen added less than zero',FATAL)

    call poolTotals(pool,totalCarbon=totalCarbon)
    if(.not.allocated(pool%litterCohorts)) call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    DO ii=1,pool%n_cohorts
        !Deposited carbon is just weighted by total cohort carbon, which we assume tracks with soil volume and mass
        IF(totalCarbon.gt.0) THEN
           weight=cohortCsum(pool%litterCohorts(ii),only_active=.TRUE.)/totalCarbon
        ELSE
           weight=1.0
        ENDIF

        pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC+litterCval*weight
        pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC+protectedCval*weight
        pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC+livingMicrobeCval*weight
        pool%litterCohorts(ii)%CO2=pool%litterCohorts(ii)%CO2+CO2val*weight
        pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC+(sum(litterCval+protectedCval)+livingMicrobeCval+CO2val)*weight

if(soil_carbon_option == SOILC_CORPSE_N) then  !May be unnecessary to "if" this if these are always zero?
        pool%litterCohorts(ii)%litterN=pool%litterCohorts(ii)%litterN+litterNval*weight!xz
    	pool%litterCohorts(ii)%protectedN=pool%litterCohorts(ii)%protectedN+protectedNval*weight!xz
    	pool%litterCohorts(ii)%livingMicrobeN=pool%litterCohorts(ii)%livingMicrobeN+livingMicrobeNval*weight!xz
    	pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN+(sum(litterNval+protectedNval)+livingMicrobeNval)*weight!xz
endif

    ENDDO

end subroutine add_C_N_to_cohorts


subroutine add_C_N_to_rhizosphere(pool,newCarbon,newNitrogen)
    type(soil_pool),intent(inout)::pool
    real,intent(in)::newCarbon(n_c_types),newNitrogen(n_c_types)

    type(litterCohort)::rhizosphere,newcohort
    real::litterC_removed(n_c_types),protectedC_removed(n_c_types),liveMicrobeC_removed
    real::litterN_removed(n_c_types),protectedN_removed(n_c_types),liveMicrobeN_removed
    integer::n

    if(.NOT. use_rhizosphere_cohort) then
        !call remove_carbon_fraction_from_pool(pool,rhizosphere_frac,litter_removed,protected_removed,liveMicrobe_removed)
        !call initializeCohort(rhizosphere,litter_removed+newCarbon,liveMicrobe_removed)
        !call add_cohort(pool,rhizosphere)
        ! -- Note, I don't think this implementation was used, and it is problematic because it gets called so often

        !Matching prior implementation, this carbon is just spread through soil
        call add_C_N_to_cohorts(pool,litterC=newCarbon,litterN=newNitrogen)
    else
        call initializeCohort(newcohort,newCarbon,newNitrogen)
        !New functionality: Rhizosphere is a fixed cohort, just add carbon to that
        !Ignores rhizosphere_frac
        call combine_cohorts(newcohort,pool%litterCohorts(RHIZ),rhizosphere)
        pool%litterCohorts(RHIZ)=rhizosphere
    endif

    do n=1,pool%n_cohorts
       IF (.NOT. check_cohort(pool%litterCohorts(n))) THEN
            WRITE (*,*),'add_C_N_to_rhizosphere: Cohort',n,'of',pool%n_cohorts,'bad'
            call print_cohort(pool%litterCohorts(n))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo
end subroutine add_C_N_to_rhizosphere



!Remove a fraction of carbon from all cohorts.  For processes like leaching and bioturbation
subroutine remove_C_N_fraction_from_pool(pool,fractionC,fractionN,litterC_removed,protectedC_removed,liveMicrobeC_removed,&
        litterN_removed,protectedN_removed,liveMicrobeN_removed,&
        C_litterMobility,C_protectedMobility,N_litterMobility,N_protectedMobility,&
        livingMicrobeMobility)
    type(soil_pool),intent(inout) :: pool
    real,intent(in) :: fractionC,fractionN
    real,intent(out) :: litterC_removed(n_c_types),protectedC_removed(n_c_types),liveMicrobeC_removed
    real,intent(out) :: litterN_removed(n_c_types),protectedN_removed(n_c_types),liveMicrobeN_removed
    real,intent(in), optional :: C_litterMobility(n_c_types),C_protectedMobility,N_litterMobility(n_c_types),N_protectedMobility,livingMicrobeMobility

    integer::ii
    real::temp,temp2(n_c_types)
    real::C_litterFactor(n_c_types),N_litterFactor(n_c_types),C_protectedFactor,N_protectedFactor,liveMicrobeFactor

    C_litterFactor=1.0
    C_protectedFactor=1.0
    N_litterFactor=1.0
    N_protectedFactor=1.0
    liveMicrobeFactor=1.0

    IF (present(C_litterMobility)) C_litterFactor=C_litterMobility
    IF (present(C_protectedMobility)) C_protectedFactor=C_protectedMobility
    IF (present(N_litterMobility)) N_litterFactor=N_litterMobility
    IF (present(N_protectedMobility)) N_protectedFactor=N_protectedMobility
    IF (present(livingMicrobeMobility)) liveMicrobeFactor=livingMicrobeMobility

    if(fractionC>1.0) call error_mesg('remove_C_N_fraction_from_pool','fractionC > 1.0',FATAL)
    if(fractionN>1.0) call error_mesg('remove_C_N_fraction_from_pool','fractionN > 1.0',FATAL)


    litterC_removed=0.0
    protectedC_removed=0.0
    liveMicrobeC_removed=0.0
    litterN_removed=0.0
    protectedN_removed=0.0
    liveMicrobeN_removed=0.0

    IF(allocated(pool%litterCohorts)) THEN

        DO ii=1,pool%n_cohorts
            !Carbon
            temp2=pool%litterCohorts(ii)%litterC*min(1.0,fractionC)*C_litterFactor
            litterC_removed=litterC_removed+temp2
            pool%litterCohorts(ii)%litterC=pool%litterCohorts(ii)%litterC-temp2
            pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

            temp2=pool%litterCohorts(ii)%protectedC*min(1.0,fractionC)*C_protectedFactor
            protectedC_removed=protectedC_removed+temp2
            pool%litterCohorts(ii)%protectedC=pool%litterCohorts(ii)%protectedC-temp2
            pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-sum(temp2)

            temp=pool%litterCohorts(ii)%livingMicrobeC*min(1.0,fractionC)*liveMicrobeFactor
            liveMicrobeC_removed=liveMicrobeC_removed+temp
            pool%litterCohorts(ii)%livingMicrobeC=pool%litterCohorts(ii)%livingMicrobeC-temp
            pool%litterCohorts(ii)%originalLitterC=pool%litterCohorts(ii)%originalLitterC-temp

            !Nitrogen
        if(soil_carbon_option == SOILC_CORPSE_N) THEN
            temp2=pool%litterCohorts(ii)%litterN*min(1.0,fractionN)*N_litterFactor
            litterN_removed=litterN_removed+temp2
            pool%litterCohorts(ii)%litterN=pool%litterCohorts(ii)%litterN-temp2
            pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-sum(temp2)

            temp2=pool%litterCohorts(ii)%protectedN*min(1.0,fractionN)*N_protectedFactor
            protectedN_removed=protectedN_removed+temp2
            pool%litterCohorts(ii)%protectedN=pool%litterCohorts(ii)%protectedN-temp2
            pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-sum(temp2)

            temp=pool%litterCohorts(ii)%livingMicrobeN*min(1.0,fractionN)*liveMicrobeFactor
            liveMicrobeN_removed=liveMicrobeN_removed+temp
            pool%litterCohorts(ii)%livingMicrobeN=pool%litterCohorts(ii)%livingMicrobeN-temp
            pool%litterCohorts(ii)%originalLitterN=pool%litterCohorts(ii)%originalLitterN-temp
        ELSE
            litterN_removed=0.0
            protectedN_removed=0.0
            liveMicrobeN_removed=0.0
        ENDIF
        ENDDO
    ENDIF
end subroutine remove_C_N_fraction_from_pool


subroutine remove_cohort(pool,num)
    type(soil_pool),intent(inout)::pool
    integer,intent(in)::num

    integer :: i
    !PRINT *,'Removing cohort',num
    IF (num > pool%n_cohorts) call error_mesg('remove_cohort','Tried to remove nonexistent soil cohort', FATAL)

    do i = num, pool%n_cohorts-1
       pool%litterCohorts(i) = pool%litterCohorts(i+1)
    enddo
    pool%n_cohorts = pool%n_cohorts - 1
    ! note that the cohort array does not shrink, because it is likely it'll
    ! need to be expanded in the future
end subroutine remove_cohort



 subroutine combine_cohorts(cohort1,cohort2,result)
    type(litterCohort),intent(in)::cohort1,cohort2
    type(litterCohort),intent(out)::result

    call initializeCohort(result)

    result%litterC=(cohort1%litterC + cohort2%litterC)
    result%protectedC=cohort1%protectedC + cohort2%protectedC
    result%litterN=(cohort1%litterN + cohort2%litterN)
    result%protectedN=cohort1%protectedN + cohort2%protectedN

    result%livingMicrobeC=(cohort1%livingMicrobeC + cohort2%livingMicrobeC)
    result%livingMicrobeN=(cohort1%livingMicrobeN + cohort2%livingMicrobeN)

    result%CO2=(cohort1%CO2 + cohort2%CO2)
    result%Rtot=(cohort1%Rtot + cohort2%Rtot)
    result%originalLitterC=(cohort1%originalLitterC + cohort2%originalLitterC)
    result%originalLitterN=(cohort1%originalLitterN + cohort2%originalLitterN)!xz
    result%MINER_prod=(cohort1%MINER_prod + cohort2%MINER_prod)!xz
    result%IMM_Nprod=(cohort1%IMM_Nprod + cohort2%IMM_Nprod)!xz
    result%MINER_gross=(cohort1%MINER_gross + cohort2%MINER_gross)
    result%IMM_N_gross=(cohort1%IMM_N_gross + cohort2%IMM_N_gross)
    !Cbefore=cohortCsum(cohort1)*cohort1%cohortVolume+cohortCsum(cohort2)*cohort2%cohortVolume
    !Cafter=cohortCsum(result)*result%cohortVolume

    !IF (Cbefore.ne.Cafter) PRINT *,'Error in combining cohorts:',Cafter-Cbefore

    if(.NOT. check_cohort(result)) then
        print *,'Invalid cohort generated'
        call print_cohort(result)
        call error_mesg('combine_cohorts','Resulting cohort invalid',FATAL)
    endif


end subroutine


!Returns the cohort with all fields multiplied by x
pure function multiply_cohort(cohort,x) result(result)
    type(litterCohort),intent(in) :: cohort
    real,intent(in) :: x
    type(litterCohort) :: result

    call initializeCohort(cohort=result,litterInputC=cohort%litterC,litterInputN=cohort%litterN, &
					initialMicrobeC=cohort%livingMicrobeC,initialMicrobeN=cohort%livingMicrobeN, &
					initialProtectedC=cohort%protectedC,initialProtectedN=cohort%protectedN, &
					multiplier=x,CO2=cohort%CO2)
    result%Rtot=cohort%Rtot*x

    !Need to check these
    result%IMM_Nprod=result%IMM_Nprod*x
    result%MINER_prod=result%MINER_prod*x
    result%IMM_N_gross=result%IMM_N_gross*x
    result%MINER_gross=result%MINER_gross*x

end function multiply_cohort


!Combine two soil_carbon_pool pools, with weighting
subroutine combine_pools(pool1,pool2,w1,w2)
    type(soil_pool),intent(in) :: pool1
    type(soil_pool),intent(inout) :: pool2
    real :: w1,w2,x1,x2
    integer::cc

    ! Make sure weights are normalized
    x1 = w1/(w1+w2)
    x2 = 1.0 - x1

    !First multiply existing cohorts by weighting
    IF(pool2%n_cohorts>0) THEN
      DO cc=1,pool2%n_cohorts
          pool2%litterCohorts(cc)=multiply_cohort(pool2%litterCohorts(cc),x2)
      ENDDO
    ENDIF

    !Then just add the cohorts in pool1 to pool2, with weights
    ! Note: Should this do something different if using rhizosphere and bulk soil structure?
    IF (pool1%n_cohorts>0) THEN
      DO cc=1,pool1%n_cohorts
          call add_cohort(pool2,multiply_cohort(pool1%litterCohorts(cc),x1))
      ENDDO
    ENDIF

    call cull_cohorts(pool2)
    pool2%dissolved_carbon=pool2%dissolved_carbon*x2 + pool1%dissolved_carbon*x1
    pool2%dissolved_nitrogen=pool2%dissolved_nitrogen*x2 + pool1%dissolved_nitrogen*x1
    pool2%ammonium=pool2%ammonium*x2 + pool1%ammonium*x1
    pool2%nitrate=pool2%nitrate*x2 + pool1%nitrate*x1
    pool2%nitrif=pool2%nitrif*x2 + pool1%nitrif*x1
    pool2%denitrif=pool2%denitrif*x2 + pool1%denitrif*x1
end subroutine combine_pools


!transfers a fraction of one pool into another, preserving cohorts
! Should this do something different for the rhiz and bulk soil structure?
subroutine transfer_pool_fraction(source, destination, fraction)
    type(soil_pool), intent(inout) :: source, destination
    real, intent(in) :: fraction

    integer::nn
    type(litterCohort)::transfer_cohort

    if(fraction>1.0) call error_mesg('transfer_pool_fraction','fraction > 1.0',FATAL)
    if(fraction<0.0) call error_mesg('transfer_pool_fraction','fraction < 0.0',FATAL)

    do nn=1,source%n_cohorts
        transfer_cohort=multiply_cohort(source%litterCohorts(nn),fraction)
        call add_cohort(destination,transfer_cohort)
        source%litterCohorts(nn)=multiply_cohort(source%litterCohorts(nn),1.0-fraction)
    enddo

    destination%dissolved_carbon=destination%dissolved_carbon+source%dissolved_carbon*fraction
    source%dissolved_carbon=source%dissolved_carbon*(1.0-fraction)

    destination%dissolved_nitrogen=destination%dissolved_nitrogen+source%dissolved_nitrogen*fraction
    source%dissolved_nitrogen=source%dissolved_nitrogen*(1.0-fraction)

    destination%ammonium=destination%ammonium+source%ammonium*fraction
    source%ammonium=source%ammonium*(1.0-fraction)

    destination%nitrate=destination%nitrate+source%nitrate*fraction
    source%nitrate=source%nitrate*(1.0-fraction)

    destination%nitrif=destination%nitrif+source%nitrif*fraction
    source%nitrif=source%nitrif*(1.0-fraction)

    destination%denitrif=destination%denitrif+source%denitrif*fraction
    source%denitrif=source%denitrif*(1.0-fraction)

    do nn=1,source%n_cohorts
         IF (.NOT. check_cohort(source%litterCohorts(nn))) THEN
              WRITE(*,*),'transfer_pool_fraction: Cohort',nn,'of',source%n_cohorts,'bad'
            call print_cohort(source%litterCohorts(nn))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo


    do nn=1,destination%n_cohorts
         IF (.NOT. check_cohort(destination%litterCohorts(nn))) THEN
              WRITE(*,*),'transfer_pool_fraction: Cohort',nn,'of',destination%n_cohorts,'bad'
            call print_cohort(destination%litterCohorts(nn))
            call error_mesg('add_C_N_to_rhizosphere','Bad cohort',FATAL)
       ENDIF
    enddo


end subroutine

!Sums all cohorts in layer into a single cohort
type(litterCohort) function totalPoolCohort(pool)
    type(litterCohort)::tempCohort
    type(soil_pool),intent(in)::pool
    integer::ii


    call initializeCohort(totalPoolCohort)

    do ii=1,pool%n_cohorts
        call combine_cohorts(pool%litterCohorts(ii),totalPoolCohort,tempCohort)
        totalPoolCohort=tempCohort
    enddo
end function



 subroutine poolTotals(pool,fastC,fastN,slowC,slowN,deadMicrobeC,deadMicrobeN,liveMicrobeC,liveMicrobeN,protectedC,protectedN,&
        fast_dissolvedC,slow_dissolvedC,deadmic_dissolvedC,fast_dissolvedN,slow_dissolvedN,deadmic_dissolvedN,ncohorts,totalCarbon,totalNitrogen,&
        fast_protectedC,slow_protectedC,deadmic_protectedC,fast_protectedN,slow_protectedN,deadmic_protectedN)
    real, intent(out),optional::fastC,fastN,slowC,slowN,deadMicrobeC,deadMicrobeN,&
                                liveMicrobeC,liveMicrobeN,protectedC,protectedN,totalCarbon,totalNitrogen,&
                                fast_dissolvedC,slow_dissolvedC,deadmic_dissolvedC,fast_dissolvedN,slow_dissolvedN,deadmic_dissolvedN,&
                                fast_protectedC,slow_protectedC,deadmic_protectedC,fast_protectedN,slow_protectedN,deadmic_protectedN
    integer, intent(out),optional::ncohorts
    type(soil_pool),intent(in)::pool

    type(litterCohort)::totalCohort
    integer::n

    totalCohort=totalPoolCohort(pool)

    if (present(fastC)) fastC=totalCohort%litterC(1)
    if (present(fastN)) fastN=totalCohort%litterN(1)
    if (present(slowC)) slowC=totalCohort%litterC(2)
    if (present(slowN)) slowN=totalCohort%litterN(2)
    if (present(deadMicrobeC)) deadMicrobeC=totalCohort%litterC(3)
    if (present(deadMicrobeN)) deadMicrobeN=totalCohort%litterN(3)
    if (present(liveMicrobeC)) liveMicrobeC=totalCohort%livingMicrobeC
    if (present(liveMicrobeN)) liveMicrobeN=totalCohort%livingMicrobeN
    if (present(protectedC)) protectedC=sum(totalCohort%protectedC)
    if (present(protectedN)) protectedN=sum(totalCohort%protectedN)
    if (present(fast_protectedC)) fast_protectedC=totalCohort%protectedC(1)
    if (present(fast_protectedN)) fast_protectedN=totalCohort%protectedN(1)
    if (present(slow_protectedC)) slow_protectedC=totalCohort%protectedC(2)
    if (present(slow_protectedN)) slow_protectedN=totalCohort%protectedN(2)
    if (present(deadmic_protectedC)) deadmic_protectedC=totalCohort%protectedC(3)
    if (present(deadmic_protectedN)) deadmic_protectedN=totalCohort%protectedN(3)
    if (present(fast_dissolvedC)) fast_dissolvedC=pool%dissolved_carbon(1)
    if (present(slow_dissolvedC)) slow_dissolvedC=pool%dissolved_carbon(2)
    if (present(deadmic_dissolvedC)) deadmic_dissolvedC=pool%dissolved_carbon(3)
    if (present(fast_dissolvedN)) fast_dissolvedN=pool%dissolved_nitrogen(1)
    if (present(slow_dissolvedN)) slow_dissolvedN=pool%dissolved_nitrogen(2)
    if (present(deadmic_dissolvedN)) deadmic_dissolvedN=pool%dissolved_nitrogen(3)
    if (present(totalCarbon)) totalCarbon=sum(totalCohort%litterC)+sum(totalCohort%protectedC)+&
            totalCohort%livingMicrobeC+sum(pool%dissolved_carbon)
    if (present(totalNitrogen)) totalNitrogen=sum(totalCohort%litterN)+sum(totalCohort%protectedN)+&
            totalCohort%livingMicrobeN+sum(pool%dissolved_nitrogen)+pool%ammonium+pool%nitrate

    if (present(ncohorts)) then
        ncohorts=0
        do n=1,pool%n_cohorts
            if (cohortCsum(pool%litterCohorts(n)).gt.0.0) ncohorts=ncohorts+1
        enddo
    endif
end subroutine poolTotals


function pool_total_carbon(pool) result(s)
   type(soil_pool), intent(in) :: pool
   real :: s

   integer :: i

   s = sum(pool%dissolved_carbon)
   do i = 1, pool%n_cohorts
      s = s + sum(pool%litterCohorts(i)%litterC(:))    &
            + sum(pool%litterCohorts(i)%protectedC(:)) &
            + pool%litterCohorts(i)%livingMicrobeC
   enddo
end function pool_total_carbon

!Combine cohorts in a pool, making sure the total number is less than the pool max cohorts
subroutine cull_cohorts(pool)
    type(soil_pool),intent(inout)::pool
    integer::n,ncombined,m,c1,c2
    real::Cbefore,Cafter,minDistance,r
    type(litterCohort)::tempCohort

    ncombined=0

    DO WHILE(pool%n_cohorts>pool%max_cohorts)
        !Find closest pair of cohorts
        minDistance = HUGE(1.0)
        do n = 1, pool%n_cohorts
           do m = n+1, pool%n_cohorts
              r = cohortDistance(pool%litterCohorts(n),pool%litterCohorts(m))
              if (r<minDistance) then
                 minDistance = r; c1=n; c2=m
              endif
           enddo
        enddo
        call combine_cohorts(pool%litterCohorts(c1),pool%litterCohorts(c2),tempCohort)
        !PRINT '("At cohort ceiling (",I3,"): combined cohorts ",I3," and ",I3,",difference=",F8.3)',pool%max_Cohorts,c1,c2,minDistance
        pool%litterCohorts(c1)=tempCohort
        call remove_cohort(pool,c2)
        ncombined=ncombined+1
    ENDDO

    !Cafter=cohortCsum(totalCarbonCohort(pool))
    !IF(ncombined.gt.0) WRITE (*,*),'Combined',ncombined,'cohorts'
    !totalCombineError=totalCombineError+(Cafter-Cbefore)

end subroutine cull_cohorts



!Calculate a numerical estimate of the difference between two cohorts,
!for deciding which are the closest and can be combined
real function cohortDistance(cohort1,cohort2)
    type(litterCohort)::cohort1,cohort2
    real::sum1,sum2

    !sum1=cohortCsum(cohort1,.TRUE.)
    !sum2=cohortCsum(cohort2,.TRUE.)
    sum1=sum(cohort1%litterC)
    sum2=sum(cohort2%litterC)

    IF (sum1.eq.0.0 .or. sum2.eq.0.0) THEN
        cohortDistance=0.0
    ELSE

        cohortDistance=sqrt(Cpoolcomp(cohort1%litterC(1),sum1,cohort2%litterC(1),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(2),sum1,cohort2%litterC(2),sum2,.FALSE.)**2 &
                    + Cpoolcomp(cohort1%litterC(3),sum1,cohort2%litterC(3),sum2,.FALSE.)**2 &
                    !+ Cpoolcomp(sum(cohort1%protectedC),sum1,sum(cohort2%protectedC),sum2,.TRUE.)**2 &
                    !+ (Cpoolcomp(cohort1%livingMicrobeC,sum1,cohort2%livingMicrobeC,sum2,.FALSE.))**2 &
                    )

    ENDIF

end function


!Calculate the difference between two cohort carbon pools.  Used to decide if the cohorts can be combined
real function Cpoolcomp(pool1,sum1,pool2,sum2,norm) result(compval)
    real, intent(in)::pool1,sum1,pool2,sum2
    logical,intent(in)::norm
    real::poolmean,pooldiff
    real::normval


    poolmean=0.5*(pool1/sum1+pool2/sum2)
    pooldiff=abs(pool1/sum1-pool2/sum2)

    IF (norm) THEN
        normval=poolmean
    ELSE
        normval=1.0
    ENDIF

    IF (poolmean.EQ.0.0) THEN
    compval=0.0
    ELSE
    compval=pooldiff/normval
    ENDIF
end function

!!!xz this following subroutine is adopted from CH's code using concentration over water; please note that the units of some input variables are different. I kept tracer_advection_ORI following this subroutine
subroutine tracer_advection(tracer_mass,flow,div,dz,del_tracer,divergence_loss,wl)  !wl was added here compared to the old version
    real,intent(inout),dimension(:):: tracer_mass  !Per layer (not per unit water)
    real,intent(in),dimension(:)   :: flow  !Total flow into layer, not flow rate (m)
    real,intent(in),dimension(:)   :: div   !Horizontal divergence (layer total, not rate) (m)
    real,intent(in),dimension(:)   :: dz    !Layer thickness (m)
    real,intent(out),dimension(:)  :: del_tracer,divergence_loss !Change in tracer mass, and divergence part
    real,intent(in),dimension(:)   ::wl  !water content (mm) of each soil layer to match Zack's code

    real,dimension(size(tracer_mass)) :: aaa,bbb,ccc,ddd,wl_litter    !Matrix coefficients for aaa*dx[i-1] + bbb*dx[i] + ccc*dx[i+1] = ddd
    real,dimension(size(tracer_mass)) :: u_minus,u_plus   !For weighting of flow upstream/downstream
    real,dimension(size(tracer_mass)) :: tracer_concentration  !(kg C/ m³ water)
    integer::ll,nlayers
    ! real,dimension(size(tracer_mass)) ::flow_eff ! flow adjusted to be units of [m], weighted by 1/wl  ZACK'S CODE
    real, parameter                   :: minwl = 0.1 ![mm] minimum allowed wl
    real,parameter::dens_h2o=1000.   ! kg/m3
!    real*8,parameter::porosity=0.3  !CH valore inventato  !xz volumn of water over volumn of soil; need to consider to change!!
    !real,intent(in)::theta
    !real*8::dt=1.0/(48.0*365.0)


    nlayers=size(tracer_concentration)
    wl_litter(1)=dz(1)     !m
    do ll=2,nlayers
      wl_litter(ll)=max(wl(ll-1), minwl)/dens_h2o  !m
    enddo

    tracer_concentration=tracer_mass/wl_litter   !kg/m3  !concentration computed over the volume of water


    u_minus = 1.
    where (flow.lt.0.) u_minus = 0.
    do ll = 1, nlayers-1
        u_plus(ll) = 1. - u_minus(ll+1)
    enddo

    !Top layer, uses upper bound concentration

    ll=1
    aaa(ll)= dfloat(0) !flow(ll)*u_minus(ll)
    bbb(ll)= flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - wl_litter(ll)
  !   m           m                          m                           m

    !divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)   BEN CODE ORIGINAL
    divergence_loss(ll)=max(div(ll),dfloat(0))*tracer_concentration(ll)
    ! [kg/m^2]         =       [m]        *    [kg/m^3]

    ccc(ll)= -flow(ll+1)*u_plus(ll)
    !m

    ddd(ll)= - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll)) - tracer_concentration(ll+1)*ccc(ll)
 !    kg/m2          kg/m3                       m                    kg/m3                 m

    do ll=2,nlayers-1
        !aaa(ll)=flow(ll)*u_minus(ll)     !BEN ORIGINAL
        !bbb(ll)=flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - dz(ll)
        !divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
        !ccc(ll)=-flow(ll+1)*u_plus(ll)
        !ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll)) - tracer_concentration(ll+1)*ccc(ll)

!Adapted from ZACK's CODE
     aaa(ll)=flow(ll)*u_minus(ll)
        bbb(ll)=flow(ll)*(1-u_minus(ll)) - flow(ll+1)*(1-u_plus(ll)) - wl_litter(ll)
        divergence_loss(ll)=max(div(ll),dfloat(0))*tracer_concentration(ll)     ! [kg/m^3]
!         kg/m2            =    m           *    kg/m3
        ccc(ll)=-flow(ll+1)*u_plus(ll)   !m
        ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll)) - tracer_concentration(ll+1)*ccc(ll)
   !    kg/m2
     enddo


    !bottom layer, flow out is zero
   ! ll=nlayers
   ! aaa(ll)=flow(ll)*u_minus(ll)
   ! bbb(ll)= flow(ll)*(1-u_minus(ll)) - dz(ll)
   ! divergence_loss(ll)=max(div(ll),0.0)*tracer_concentration(ll)
   ! ccc(ll)= 0.0
   ! ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll))

!Adapted from ZACK's CODE
    ll=nlayers
    aaa(ll)=flow(ll)*u_minus(ll)
    bbb(ll)= flow(ll)*(1-u_minus(ll)) - wl_litter(ll)
    divergence_loss(ll)=max(div(ll),dfloat(0))*tracer_concentration(ll)
    ccc(ll)= dfloat(0)
    ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+wl_litter(ll))


    !Solve the linear algebra problem
    if(nlayers.gt.1) then
        call tridiag(aaa,bbb,ccc,ddd,del_tracer)  !kg/m3
    else
        del_tracer=dfloat(0)
    endif


    del_tracer=del_tracer*wl_litter   !kg/m2   !variazione del tracer
    tracer_mass=tracer_mass+del_tracer    !kg/m2
    divergence_loss=divergence_loss

    where(divergence_loss>tracer_mass) divergence_loss=tracer_mass


    !WRITE(10,'(12f20.15)')del_tracer,tracer_mass,divergence_loss

end subroutine tracer_advection

!
! subroutine tracer_advection_prev(tracer_mass,flow,div,dz,wl,del_tracer,divergence_loss)
!     real,intent(inout),dimension(:):: tracer_mass  !Per layer (not per unit water)
!     real,intent(in),dimension(:)   :: flow  !Total flow, not flow rate [mm]
!     real,intent(in),dimension(:)   :: div   !Horizontal divergence (layer total, not rate) [mm]
!     real,intent(in),dimension(:)   :: dz    !Layer thickness
!     real,intent(in),dimension(:)   :: wl    !water content [kg/m^2] by layer before Richards (1:num_l)
!     real,intent(out),dimension(:)  :: del_tracer,divergence_loss !Change in tracer mass, and divergence part
!
!     real,dimension(size(tracer_mass)) :: aaa,bbb,ccc,ddd    !Matrix coefficients for aaa*dx[i-1] + bbb*dx[i] + ccc*dx[i+1] = ddd
!     real,dimension(size(tracer_mass)) :: u_minus,u_plus   !For weighting of flow upstream/downstream
!     real,dimension(size(tracer_mass)) :: tracer_concentration ! [kg C/m^3 soil]
!     integer::ll,nlayers
!     real,dimension(size(tracer_mass)) :: flow_eff ! flow adjusted to be units of [m], weighted by 1/wl
!     real, parameter                   :: minwl = 0.1 ![mm] minimum allowed wl
!
!     nlayers=size(tracer_concentration)
!     tracer_concentration=tracer_mass/dz
!     ! ZMS
! !    tracer_concentration(1) = tracer_mass(1)/dz(1)
! !    do ll=2,nlayers
! !       if (wl(ll-1) > 0.) then
! !          tracer_concentration(ll) = tracer_mass(ll)/(wl(ll-1)/dens_h2o)
! !       else
! !          tracer_concentration(ll) = tracer_mass(ll)/dz(ll)
! !       end if
! !    end do
!
!     ! Adjust flow to be in units of m, weighted by 1/wl
!     ! wl of litter layer is undefined
!     flow_eff(1) = flow(1)/dens_h2o ! This should be zero
!     if (flow(2) > 0.) then
!        flow_eff(2) = flow(2)/dens_h2o
!        ! [m]       = [mm]/[mm/m]
!     else
!        flow_eff(2) = flow(2) * dz(2)/max(wl(1), minwl)
!        ! [m]       = [mm]    * [m]  / [mm]
!     end if
!     do ll = 3, nlayers
!        if (flow(ll) > 0.) then
!           flow_eff(ll) = flow(ll) * dz(ll-1)/max(wl(ll-2), minwl)
!        else
!           flow_eff(ll) = flow(ll) * dz(ll)/max(wl(ll-1), minwl)
!        end if
!     end do
!
!     u_minus = 1.
!     where (flow.lt.0.) u_minus = 0.
!     do ll = 1, nlayers-1
!         u_plus(ll) = 1. - u_minus(ll+1)
!     enddo
!
!     !Top layer, uses upper bound concentration
!     ! flow into top layer is zero
!     ll=1
!     aaa(ll)= 0.0 !flow(ll)*u_minus(ll)
!     bbb(ll)= - flow_eff(ll+1)*(1-u_plus(ll)) - dz(ll)
!     divergence_loss(ll)=max(div(ll),0.0)/dz(ll)/dens_h2o*tracer_concentration(ll)
!     ! [kg/m^3]         =   [mm]         / [m]  / [mm/m] * [kg/m^3]
!     ccc(ll)= -flow_eff(ll+1)*u_plus(ll)
!     ddd(ll)= - tracer_concentration(ll)*(bbb(ll)+dz(ll)) - tracer_concentration(ll+1)*ccc(ll)
!     do ll=2,nlayers-1
!         aaa(ll)=flow_eff(ll)*u_minus(ll)
!         bbb(ll)=flow_eff(ll)*(1-u_minus(ll)) - flow_eff(ll+1)*(1-u_plus(ll)) - dz(ll)
!         divergence_loss(ll)=max(div(ll),0.0)/max(wl(ll-1),minwl)*tracer_concentration(ll)
!         ! [kg/m^3]         =     [mm]       / [mm]              * [kg/m^3]
!         ccc(ll)=-flow_eff(ll+1)*u_plus(ll)
!         ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll)) - tracer_concentration(ll+1)*ccc(ll)
!     enddo
!     !bottom layer, flow out is zero
!     ll=nlayers
!     aaa(ll)=flow_eff(ll)*u_minus(ll)
!     bbb(ll)= flow_eff(ll)*(1-u_minus(ll)) - dz(ll)
!     divergence_loss(ll)=max(div(ll),0.0)/max(wl(ll-1),minwl)*tracer_concentration(ll)
!     ccc(ll)= 0.0
!     ddd(ll)=-tracer_concentration(ll-1)*aaa(ll) - tracer_concentration(ll)*(bbb(ll)+dz(ll))
!
!     !Solve the linear algebra problem
!     if(nlayers.gt.1) then
!         call tridiag(aaa,bbb,ccc,ddd,del_tracer)
!     else
!         del_tracer=0.0
!     endif
!
!
!     del_tracer=del_tracer*dz
!     tracer_mass=tracer_mass+del_tracer
!     divergence_loss=divergence_loss*dz
!     where(divergence_loss>tracer_mass) divergence_loss=tracer_mass
!
! end subroutine tracer_advection_prev





subroutine tracer_leaching_with_litter(soil,wl,leaflitter,woodlitter,flow,litterflow,div,dz,dt,del_soil_DOC,&
			del_leaflitter_DOC,del_woodlitter_DOC,div_DOC_loss,&
			tiled,div_hlsp_DOC,surf_DOC_loss,div_hlsp_DON,surf_DON_loss,div_hlsp_NO3,surf_NO3_loss,div_hlsp_NH4,surf_NH4_loss,&
			del_soil_DON,del_leaflitter_DON,del_woodlitter_DON,div_DON_loss,del_soil_NH4,del_soil_NO3,del_leaflitter_NH4,&
			del_leaflitter_NO3,del_woodlitter_NH4,del_woodlitter_NO3,div_NH4_loss,div_NO3_loss)

!xz note: wl soil layer water volumn, mm^3/mm^2, defined by CH ; div, divergent flux or horizontal flow; del is the change along the time dimension


    !type(soil_carbon_pool),dimension(:),intent(inout)::soil
    !type(soil_carbon_pool),intent(inout)::leaflitter,woodlitter
    type(soil_pool),dimension(:),intent(inout)::soil!xz
    type(soil_pool),intent(inout)::leaflitter,woodlitter!xz

!!xz check the unit of flow!!For CH's code, it should be kg/year or kg/dt's unit.!!! I assume here the unit is mm/yr
    real,dimension(:),intent(in)::flow,div,dz,wl !flow (into layer) and wl in units of mm, downward is >0  !!!xz check the unit of dz (should be m in this subroutine), flow (shoul be mm)
    real,intent(in)  :: litterflow  !Flow and divergence for litter layer
    real,intent(in)::dt                       ! time step, s

    real*8,parameter::dens_h2o=1000.0 !xz

    logical, intent(in) :: tiled ! flag for tiled hydrology

!!!!!!!xz we might need to update this part sine CH and Ben's code do not have N lost from run off ; need to consider to add surf_DON_loss; and div_hlsp_DON
    real, optional, intent(in) :: div_hlsp_DOC(:,:) ! dim(n_c_types, num_l) [kg C/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_DOC_loss(n_c_types) ! [kg C/m^2] loss from top layer to surface runoff
    real, optional, intent(in) :: div_hlsp_DON(:,:) ! dim(n_c_types, num_l) [kg N/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_DON_loss(n_c_types) ! [kg N/m^2] loss from top layer to surface runoff
    real, optional, intent(in) :: div_hlsp_NO3(:),div_hlsp_NH4(:) ! dim(num_l) [kg N/m^2/s] net divergence
                                                    ! loss from tile calculated in hlsp_hydrology
    real, optional, intent(out) :: surf_NO3_loss,surf_NH4_loss ! [kg N/m^2] loss from top layer to surface runoff
!!!!!!!xz [end]

    !real,intent(out),optional::del_soil_DOC(:,:),div_DOC_loss(:,:),del_leaflitter_DOC(:),del_woodlitter_DOC(:) !xz
    real,intent(out),optional::del_soil_DOC(:,:),del_soil_DON(:,:),div_DOC_loss(:,:),del_leaflitter_DOC(:),del_woodlitter_DOC(:),&
								del_leaflitter_DON(:),del_woodlitter_DON(:),div_DON_loss(:,:),del_soil_NH4(:),del_soil_NO3(:),&
                                del_leaflitter_NH4,del_leaflitter_NO3, del_woodlitter_NH4,del_woodlitter_NO3,&
								div_NH4_loss(:),div_NO3_loss(:) !xz



    !real::DOC(n_c_types,size(soil)+1)!xz
    real::DOC(n_c_types,size(soil)+1), DON(n_c_types,size(soil)+1),NH4_dissolved(size(soil)+1),NO3_dissolved(size(soil)+1)!xz


!    real,dimension(n_c_types,size(soil)+1) :: div_loss!xz
    real,dimension(n_c_types,size(soil)+1) :: div_loss,div_loss_N!xz
    real,dimension(size(soil)+1)           :: div_loss_NO3,div_loss_NH4

    !real::d_DOC(n_c_types,size(soil)+1)!xz
    real::d_DOC(n_c_types,size(soil)+1),d_DON(n_c_types,size(soil)+1),d_NH4(size(soil)+1),d_NO3(size(soil)+1)!xz

    real,dimension(size(soil)+1) :: flow_with_litter, div_with_litter, dz_with_litter ! water flow
    integer::l,ii,badcohort,n

    !real::litterThickness,leaflitterTotalC,woodlitterTotalC,DOCbefore(size(soil)+1),leaf_DOC_frac!xz
    real::litterThickness,leaflitterTotalC,woodlitterTotalC,DOCbefore(size(soil)+1),DONbefore(size(soil)+1),leaf_DOC_frac,leaf_DON_frac,&
			NH4before(size(soil)+1),NO3before(size(soil)+1),leaf_NH4_frac,leaf_NO3_frac

!!!!!!!xz Not in CH's code. need to consider add N here as well.
    real :: surf_DOC_loss_loc(n_c_types), surf_DON_loss_loc(n_c_types), surf_NO3_loss_loc, surf_NH4_loss_loc
    real, parameter :: minwl = 0.1 ! [mm]
!!!!!!!xz [end]

    !For now, use a mininum litter thickness of 5 mm
    call poolTotals(leaflitter, totalCarbon=leaflitterTotalC)
    call poolTotals(woodlitter, totalCarbon=woodlitterTotalC)
    litterThickness=max((leaflitterTotalC+woodlitterTotalC)/litterDensity,5e-3)

!!!!!!!xz note: please make sure the unit of flow is ????
    flow_with_litter(1)=0.0
    flow_with_litter(2:size(flow_with_litter))=flow(1:size(flow_with_litter)-1)  !mm
    flow_with_litter=flow_with_litter/1000 !xz change the div unit from mm to m

    !flow_with_litter(1)=dfloat(0)/dens_h2o*dt  !m !CH's code if the unit of flow is kg/m2/yr
    !flow_with_litter(2:size(flow_with_litter))=flow(1:size(flow_with_litter)-1)/dens_h2o*dt   !m


    div_with_litter(1)=0.0
    div_with_litter(2:size(flow_with_litter))=div(:)*dt ! div is in mm/s
    div_with_litter=div_with_litter/1000 !xz change the div unit from mm to m

    !div_with_litter(1)=dfloat(0)/dens_h2o*dt!xz!CH's code if the unit of flow is kg/m2/yr
    !div_with_litter(2:size(flow_with_litter))=div(:)/dens_h2o*dt  !m? !xz

    dz_with_litter(1)=litterThickness
    dz_with_litter(2:size(dz_with_litter)) = dz(:) !!xz assume the unit of dz is m

    !flow_with_litter(:)=0.0
    !flow_with_litter(2:)=1e-3


IF(soil_carbon_option == SOILC_CORPSE_N) THEN
!!!!!!!!!!!!!!!!!!xz ADD CH's code for Nitrogen !!!Please Check the unit!!!!! Is the unit of the inputs from the point model the same as the CH's experiment?
    ! Probably should include wood litter in this too
    ! Ammonium should be less soluble than nitrate, probably.  Could use retrieve_dissolved_mineral_N to standardize that --BNS
    NH4_dissolved(1)=leaflitter%ammonium + woodlitter%ammonium  !kg/m2
    NH4_dissolved(2:size(soil)+1)=soil(:)%ammonium  !kg/m2

    if(NH4_dissolved(1)>0) then
        leaf_NH4_frac=leaflitter%ammonium/NH4_dissolved(1)
    else
        leaf_NH4_frac=0.0
    endif

    NO3_dissolved(1)=leaflitter%nitrate + woodlitter%ammonium   !kg/m2
    NO3_dissolved(2:size(soil)+1)=soil(:)%nitrate   !kg/m2

    if(NO3_dissolved(1)>0) then
        leaf_NO3_frac=leaflitter%nitrate/NO3_dissolved(1)
    else
        leaf_NO3_frac=0.0
    endif

    if(any(NH4_dissolved(:)<dfloat(0))) then
		print *,NH4_dissolved(:)
		call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium < 0 (before advection)',FATAL)
	endif

	if(any(NO3_dissolved(:)<dfloat(0))) then
		print *,NO3_dissolved(:)
		call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate < 0 (before advection)',FATAL)
	endif

	NH4before=NH4_dissolved(:)
	NO3before=NO3_dissolved(:)

	call tracer_advection(NH4_dissolved(:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_NH4(:),div_loss_NH4(:),wl(:))

	call tracer_advection(NO3_dissolved(:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_NO3(:),div_loss_NO3(:),wl(:))

	!la subroutine tracer_advection mi rida' il valore de la quantita di tracer_dissolved gia' aggiornata con la percolazione che entra ed esce dallo strato di suolo
	!la variazione di massa e' pari a d_NH4 o d_NO3

	if(abs(sum(NH4_dissolved(:))-sum(NH4before)).gt.1e-10) then
		print *,'Ammonium'
		print *,'Before:'
		print *,NH4before
		print *,'After:'
		print *,NH4_dissolved(:)
		print *,'Difference:'
		print *,d_NH4(:)
		print *,'Flow:'
		print *,flow_with_litter
		print *,'Total difference:',sum(NH4_dissolved(:))-sum(NH4before)
		call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium not conserved',FATAL)
	endif
	if(any(NH4_dissolved(:)<0)) call error_mesg('ammonium_leaching_with_litter','Dissolved ammonium < 0 (after advection)',FATAL)

	if(abs(sum(NO3_dissolved(:))-sum(NO3before)).gt.1e-10) then
		print *,'Nitrate'
		print *,'Before:'
		print *,NO3before
		print *,'After:'
		print *,NO3_dissolved(:)
		print *,'Difference:'
		print *,d_NO3(:)
		print *,'Flow:'
		print *,flow_with_litter
		print *,'Total difference:',sum(NO3_dissolved(:))-sum(NO3before)
		call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate not conserved',FATAL)
	endif
	if(any(NO3_dissolved(:)<0)) call error_mesg('nitrate_leaching_with_litter','Dissolved nitrate < 0 (after advection)',FATAL)


    if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
       div_loss_NO3(2:size(soil)+1) = div_hlsp_NO3(:)*dt
       div_loss_NH4(2:size(soil)+1) = div_hlsp_NH4(:)*dt
       if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff -- BNS: include litter layer in this??
          surf_NO3_loss_loc = -NO3_dissolved(2) * flow(1) / wl(1)
          surf_NO3_loss_loc = min(surf_NO3_loss_loc, NO3_dissolved(2))
          surf_NH4_loss_loc = -NH4_dissolved(2) * flow(1) / wl(1)
          surf_NH4_loss_loc = min(surf_NH4_loss_loc, NH4_dissolved(2))
       end if
       div_loss_NO3(2) = min(div_loss_NO3(2), NO3_dissolved(2) - surf_NO3_loss_loc)
       div_loss_NH4(2) = min(div_loss_NH4(2), NH4_dissolved(2) - surf_NH4_loss_loc)
       do l=3,size(soil)+1
          div_loss_NO3(l) = min(div_loss_NO3(l), NO3_dissolved(l))
          div_loss_NH4(l) = min(div_loss_NH4(l), NH4_dissolved(l))
       end do
       ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
       ! that will be effectively rectified by subtracting from the flux to stream. In rare
       ! situations, that could lead to a negative stream DOC flux.

       NH4_dissolved(2)=NH4_dissolved(2)-surf_NH4_loss_loc
       NO3_dissolved(2)=NO3_dissolved(2)-surf_NO3_loss_loc

    end if

	NH4_dissolved(:)=NH4_dissolved(:)-div_loss_NH4(:)  !aggiorno la quantita' di ammonio in soluzione nel suolo togliendo la parte che e' uscita con il flusso laterale

	NO3_dissolved(:)=NO3_dissolved(:)-div_loss_NO3(:)


	leaflitter%ammonium=NH4_dissolved(1)*leaf_NH4_frac
    woodlitter%ammonium=NH4_dissolved(1)*(1.0-leaf_NH4_frac)

	soil(:)%ammonium=NH4_dissolved(2:size(soil)+1)

	leaflitter%nitrate=NO3_dissolved(1)*leaf_NO3_frac
    woodlitter%nitrate=NO3_dissolved(1)*(1.0-leaf_NO3_frac)
	soil(:)%nitrate=NO3_dissolved(2:size(soil)+1)

	if(present(del_soil_NH4)) del_soil_NH4(:)=d_NH4(2:size(soil)+1)  !variazione con la percolazione del contenuto di NH4 nel suolo
	if(present(del_soil_NO3)) del_soil_NO3(:)=d_NO3(2:size(soil)+1)

	if(present(del_leaflitter_NH4)) del_leaflitter_NH4=d_NH4(1)*leaf_NH4_frac
	if(present(del_leaflitter_NO3)) del_leaflitter_NO3=d_NO3(1)*leaf_NO3_frac
    if(present(del_woodlitter_NH4)) del_woodlitter_NH4=d_NH4(1)*(1.0-leaf_NH4_frac)
	if(present(del_woodlitter_NO3)) del_woodlitter_NO3=d_NO3(1)*(1.0-leaf_NO3_frac)


	if(present(div_NH4_loss)) div_NH4_loss(:)=div_loss_NH4(2:size(soil)+1)
	if(present(div_NO3_loss)) div_NO3_loss(:)=div_loss_NO3(2:size(soil)+1)

!!!!!!!!!!!!!!!!!!xz [End] CH's code for Nitrogen
ELSE  ! End of code if SOILC_CORPSE_N
    if(present(surf_NO3_loss)) surf_NO3_loss=0.0
    if(present(surf_NH4_loss)) surf_NH4_loss=0.0
    if(present(del_soil_NH4)) del_soil_NH4=0.0
    if(present(del_soil_NO3)) del_soil_NO3=0.0
    if(present(del_leaflitter_NH4)) del_leaflitter_NH4=0.0
    if(present(del_leaflitter_NO3)) del_leaflitter_NO3=0.0
    if(present(del_woodlitter_NH4)) del_woodlitter_NH4=0.0
    if(present(del_woodlitter_NO3)) del_woodlitter_NO3=0.0
    if(present(div_NH4_loss)) div_NH4_loss=0.0
    if(present(div_NO3_loss)) div_NO3_loss=0.0


ENDIF

  call dissolve_carbon(leaflitter,wl(1)/(dens_h2o*dz(1))) ! Doesn't take porosity into account
  call dissolve_carbon(woodlitter,wl(1)/(dens_h2o*dz(1)))
  do ii=1, size(soil)
    call dissolve_carbon(soil(ii),wl(ii)/(dens_h2o*dz(ii)))
  enddo

    surf_DOC_loss_loc(:) = 0.0
    surf_DON_loss_loc(:) = 0.0
    do ii=1,n_c_types
       DOC(ii,1)=leaflitter%dissolved_carbon(ii)+woodlitter%dissolved_carbon(ii)


       if(DOC(ii,1)>0) then
           leaf_DOC_frac=leaflitter%dissolved_carbon(ii)/DOC(ii,1)
       else
           leaf_DOC_frac=0.0
       endif


       DOC(ii,2:size(soil)+1)=soil(:)%dissolved_carbon(ii)


       if(any(DOC(ii,:)<0)) then
           print *,'Carbon flavor',ii
           print *,DOC(ii,:)
           call error_mesg('tracer_leaching_with_litter','Dissolved carbon < 0 (before advection)',FATAL)
       endif

       DOCbefore=DOC(ii,:)


       if (is_watch_point()) then
          __DEBUG1__(DOCbefore)
       endif

       !call tracer_advection(DOC(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,wl,d_DOC(ii,:),div_loss(ii,:))!xz
       call tracer_advection(DOC(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_DOC(ii,:),div_loss(ii,:),wl(:))!xz

       if (is_watch_point()) then
          __DEBUG1__(DOC(ii,:))
       endif

       if(abs(sum(DOC(ii,:))-sum(DOCbefore)).gt.1e-10) then
           print *,'Flavor:',ii
           print *,'Before:'
           print *,DOCbefore
           print *,'After:'
           print *,DOC(ii,:)
           print *,'Difference:'
           print *,d_DOC(ii,:)
           print *,'Flow:'
           print *,flow_with_litter
           print *,'Total difference:',sum(DOC(ii,:))-sum(DOCbefore)
           call error_mesg('tracer_leaching_with_litter','Dissolved carbon not conserved',FATAL)
       endif
       if(any(DOC(ii,:)<0)) call error_mesg('tracer_leaching_with_litter','Dissolved carbon < 0 (after advection)',FATAL)

       if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
          div_loss(ii,2:size(soil)+1) = div_hlsp_DOC(ii,:)*dt
          if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff
             surf_DOC_loss_loc(ii) = -DOC(ii, 2) * flow(1) / wl(1)
             surf_DOC_loss_loc(ii) = min(surf_DOC_loss_loc(ii), DOC(ii,2))
          end if
          div_loss(ii,2) = min(div_loss(ii,2), DOC(ii,2) - surf_DOC_loss_loc(ii))
          do l=3,size(soil)+1
             div_loss(ii,l) = min(div_loss(ii,l), DOC(ii,l))
          end do
          ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
          ! that will be effectively rectified by subtracting from the flux to stream. In rare
          ! situations, that could lead to a negative stream DOC flux.
       end if
       DOC(ii,:)=DOC(ii,:)-div_loss(ii,:)
       DOC(ii,2)=DOC(ii,2)-surf_DOC_loss_loc(ii)!!xz This line does not exist in CH's code ; consider to add similar line to Nitrogen part
       ! Xin says this line was a mistake

       leaflitter%dissolved_carbon(ii)=DOC(ii,1)*leaf_DOC_frac
       woodlitter%dissolved_carbon(ii)=DOC(ii,1)*(1.0-leaf_DOC_frac)
       soil(:)%dissolved_carbon(ii)=DOC(ii,2:size(soil)+1)

       if(present(del_soil_DOC)) del_soil_DOC(ii,:)=d_DOC(ii,2:size(soil)+1)
       if(present(del_leaflitter_DOC)) del_leaflitter_DOC(ii)=d_DOC(ii,1)*leaf_DOC_frac
       if(present(del_woodlitter_DOC)) del_woodlitter_DOC(ii)=d_DOC(ii,1)*(1.0-leaf_DOC_frac)

       if(present(div_DOC_loss)) div_DOC_loss(ii,:)=div_loss(ii,2:size(soil)+1)
       if(present(surf_DOC_loss)) surf_DOC_loss(ii) = surf_DOC_loss_loc(ii)!!xz This line does not exist in CH's code

!!!!!xz Nitrogen

    IF(soil_carbon_option == SOILC_CORPSE_N) THEN

        DON(ii,1)=leaflitter%dissolved_nitrogen(ii)+woodlitter%dissolved_nitrogen(ii)!xz
         if(DON(ii,1)>0) then
             leaf_DON_frac=leaflitter%dissolved_nitrogen(ii)/DON(ii,1)
         else
             leaf_DON_frac=dfloat(0)
         endif !xz
        DON(ii,2:size(soil)+1)=soil(:)%dissolved_nitrogen(ii)!xz
        if(any(DON(ii,:)<dfloat(0))) then
             print *,'Nitrogen flavor',ii
             print *,DON(ii,:)
             call error_mesg('tracer_leaching_with_litter','Dissolved nitrogen < 0 (before advection)',FATAL)
        endif!xz
        DONbefore=DON(ii,:)!xz

       call tracer_advection(DON(ii,:),flow_with_litter(:),div_with_litter(:),dz_with_litter,d_DON(ii,:),div_loss_N(ii,:),wl(:))
		if(abs(sum(DON(ii,:))-sum(DONbefore)).gt.1e-10) then
			print *,'Flavor:',ii
			print *,'Before:'
			print *,DONbefore
			print *,'After:'
			print *,DON(ii,:)
			print *,'Difference:'
			print *,d_DON(ii,:)
			print *,'Flow:'
			print *,flow_with_litter
			print *,'Total difference:',sum(DON(ii,:))-sum(DONbefore)
			call error_mesg('nitrogen_leaching_with_litter','Dissolved nitrogen not conserved',FATAL)
		endif
		if(any(DON(ii,:)<0)) call error_mesg('nitrogen_leaching_with_litter','Dissolved nitrogen < 0 (after advection)',FATAL)



        if (tiled) then ! reset div_loss(ii,2:num_l+1) according to values calculated in hlsp_hydrology
           div_loss_N(ii,2:size(soil)+1) = div_hlsp_DON(ii,:)*dt
           if (flow(1) < 0. .and. wl(1) > minwl) then  ! Add loss from top layer to runoff
              surf_DON_loss_loc(ii) = -DON(ii, 2) * flow(1) / wl(1)
              surf_DON_loss_loc(ii) = min(surf_DON_loss_loc(ii), DON(ii,2))
           end if
           div_loss_N(ii,2) = min(div_loss_N(ii,2), DON(ii,2) - surf_DON_loss_loc(ii))
           do l=3,size(soil)+1
              div_loss_N(ii,l) = min(div_loss_N(ii,l), DON(ii,l))
           end do
           ! Note: if these limits are imposed, there will be an imbalance between inter-tile fluxes
           ! that will be effectively rectified by subtracting from the flux to stream. In rare
           ! situations, that could lead to a negative stream DOC flux.
        end if

        DON(ii,2)=DON(ii,2)-surf_DON_loss_loc(ii)!!xz This line does not exist in CH's code ; consider to add similar line to Nitrogen part
       ! Xin says this line was a mistake




		DON(ii,:)=DON(ii,:)-div_loss_N(ii,:)

		leaflitter%dissolved_nitrogen(ii)=DON(ii,1)*leaf_DON_frac
		woodlitter%dissolved_nitrogen(ii)=DON(ii,1)*(1.0-leaf_DON_frac)
		soil(:)%dissolved_nitrogen(ii)=DON(ii,2:size(soil)+1)

		if(present(del_soil_DON)) del_soil_DON(ii,:)=d_DON(ii,2:size(soil)+1)
		if(present(del_leaflitter_DON)) del_leaflitter_DON(ii)=d_DON(ii,1)*leaf_DON_frac
		if(present(del_woodlitter_DON)) del_woodlitter_DON(ii)=d_DON(ii,1)*(1.0-leaf_DON_frac)

		if(present(div_DON_loss)) div_DON_loss(ii,:)=div_loss_N(ii,2:size(soil)+1)

    ELSE

		if(present(del_soil_DON)) del_soil_DON(ii,:)=0.0
		if(present(del_leaflitter_DON)) del_leaflitter_DON(ii)=0.0
		if(present(del_woodlitter_DON)) del_woodlitter_DON(ii)=0.0

		if(present(div_DON_loss)) div_DON_loss(ii,:)=0.0
    ENDIF

!!!!xz Nitrogen [end]
    enddo

    call deposit_dissolved_C(leaflitter)
    call deposit_dissolved_C(woodlitter)
    do ii=1, size(soil)
      call deposit_dissolved_C(soil(ii))
    enddo


end subroutine tracer_leaching_with_litter


subroutine retrieve_DOC(soil, DOC, num_l)

   type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
   integer, intent(in)  :: num_l ! number of soil layers
   real, intent(out)    :: DOC(n_c_types, num_l) ! [kg C/m^2] dissolved organic carbon
   integer :: l

   do l=1,num_l
      DOC(1:n_c_types,l)=soil(l)%dissolved_carbon(1:n_c_types)
   end do

end subroutine retrieve_DOC

subroutine retrieve_DON(soil, DON, num_l)

    type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
    integer, intent(in)  :: num_l ! number of soil layers
    real, intent(out)    :: DON(n_c_types, num_l) ! [kg C/m^2] dissolved organic nitrogen
    integer :: l

    if(soil_carbon_option == SOILC_CORPSE_N) then
        do l=1,num_l
            DON(1:n_c_types,l)=soil(l)%dissolved_nitrogen(1:n_c_types)
        end do
    else
        DON=0.0
    endif
end subroutine retrieve_DON


subroutine retrieve_dissolved_mineral_N(soil,nitrate,ammonium,num_l)
    ! Maybe this should include some solubility parameter that differs between nitrate and ammonium
    type(soil_pool),dimension(:),intent(in) :: soil ! soil carbon pointer
    integer, intent(in)  :: num_l ! number of soil layers
    real, intent(out)    :: nitrate(num_l),ammonium(num_l) ! [kg N/m^2] dissolved nitrate and ammonium
    integer :: l

    if(soil_carbon_option == SOILC_CORPSE_N) then
        do l=1,num_l
            nitrate(l)=soil(l)%nitrate
            ammonium(l)=soil(l)%ammonium
        end do

    else
        nitrate=0.0
        ammonium=0.0
    endif

end subroutine retrieve_dissolved_mineral_N



function Knitrif(T)
    real*8,intent(in)::T
    real*8,parameter::Tref=293.15   !Tref is in kelvin not celcus
    real*8::alpha,Knitrif

    alpha=Knitr_ref/exp(-Ea_nitrif/(Rugas*Tref))
    Knitrif=alpha*exp(-Ea_nitrif/(Rugas*T))
end function Knitrif

function Kdenitr(T)
    real*8,intent(in)::T
    real*8,parameter::Tref=293.15   !LA TEMPERATURA É IN KELVIN ED EQUIVALE A 20ºC
    real*8::alpha,Kdenitr

    alpha=Kdenitr_ref/exp(-Ea_denitr/(Rugas*Tref))
    Kdenitr=alpha*exp(-Ea_denitr/(Rugas*T))
end function Kdenitr


function V_NH4(T)
    real*8,intent(in)::T
    real*8,parameter::Tref=293.15   !LA TEMPERATURA É IN KELVIN ED EQUIVALE A 20ºC
    real*8::alpha,V_NH4

    alpha=V_NH4_ref/exp(-Ea_NH4/(Rugas*Tref))
    V_NH4=alpha*exp(-Ea_NH4/(Rugas*T))

end function V_NH4

function V_NO3(T)
    real*8,intent(in)::T
    real*8,parameter::Tref=293.15   !Tref is in kelvin not celcus
    real*8::alpha,V_NO3

    alpha=V_NO3_ref/exp(-Ea_NO3/(Rugas*Tref))
    V_NO3=alpha*exp(-Ea_NO3/(Rugas*T))

end function V_NO3



#ifndef STANDALONE_SOIL_CARBON

! This is used for writing restart files.  Needs to be able to generate a pointer to every field of soil_pool and litterCohort that affects model behavior
subroutine get_pool_data_accessors(pool,fast_soil_C,fast_soil_N,slow_soil_C,slow_soil_N,deadMicrobeC,deadMicrobeN,livingMicrobeC,livingMicrobeN,&
    Rtot,CO2,originalLitterC, originalLitterN,&
           fast_protected_C,fast_protected_N,slow_protected_C,slow_protected_N,deadMicrobe_protected_C,deadMicrobe_protected_N,&
           fast_DOC,slow_DOC,deadMicrobe_DOC,fast_DON,slow_DON,deadMicrobe_DON,&
           ammonium,nitrate,nitrif,denitrif,IMM_N_max,IMM_N_gross,MINER_gross,MINER_prod,IMM_Nprod)
    type(soil_pool),intent(inout),target::pool
    real,pointer,dimension(:),optional::fast_soil_C,fast_soil_N,slow_soil_C,slow_soil_N,deadMicrobeC,deadMicrobeN,&
                livingMicrobeC,livingMicrobeN,Rtot,CO2,originalLitterC,originalLitterN,&
                                        fast_protected_C,fast_protected_N,slow_protected_C,slow_protected_N,deadMicrobe_protected_C,deadMicrobe_protected_N,&
                                        IMM_N_max,IMM_N_gross,MINER_gross,MINER_prod,IMM_Nprod
    real,pointer,optional :: fast_DOC,fast_DON,slow_DOC,slow_DON,deadMicrobe_DOC,deadMicrobe_DON,ammonium,nitrate,nitrif,denitrif



    integer :: n ! shorthand for pool%n_cohorts

    !First make sure the length of the litterCohorts array is right
    !Remove cohorts if size is too large
    IF (pool%n_cohorts.gt.soilMaxCohorts) call cull_cohorts(pool)

    !Add empty cohorts until size is correct
    DO WHILE (pool%n_cohorts.lt.soilMaxCohorts)
        call add_litter(pool,(/0.0,0.0,0.0/),(/0.0,0.0,0.0/))
    ENDDO

    n = pool%n_cohorts
    IF(present(livingMicrobeC)) livingMicrobeC=>pool%litterCohorts(1:n)%livingMicrobeC
    IF(present(livingMicrobeN)) livingMicrobeN=>pool%litterCohorts(1:n)%livingMicrobeN
    IF(present(Rtot))Rtot=>pool%litterCohorts(1:n)%Rtot
    IF(present(CO2))CO2=>pool%litterCohorts(1:n)%CO2
    IF(present(originalLitterC))originalLitterC=>pool%litterCohorts(1:n)%originalLitterC
    IF(present(originalLitterN))originalLitterN=>pool%litterCohorts(1:n)%originalLitterN
    IF(present(fast_soil_C))fast_soil_C=>pool%litterCohorts(1:n)%litterC(1)
    IF(present(slow_soil_C))slow_soil_C=>pool%litterCohorts(1:n)%litterC(2)
    IF(present(deadMicrobeC))deadMicrobeC=>pool%litterCohorts(1:n)%litterC(3)
    IF(present(fast_soil_N))fast_soil_N=>pool%litterCohorts(1:n)%litterN(1)
    IF(present(slow_soil_N))slow_soil_N=>pool%litterCohorts(1:n)%litterN(2)
    IF(present(deadMicrobeN))deadMicrobeN=>pool%litterCohorts(1:n)%litterN(3)
    IF(present(fast_protected_C))fast_protected_C=>pool%litterCohorts(1:n)%protectedC(1)
    IF(present(slow_protected_C))slow_protected_C=>pool%litterCohorts(1:n)%protectedC(2)
    IF(present(deadMicrobe_protected_C))deadMicrobe_protected_C=>pool%litterCohorts(1:n)%protectedC(3)
    IF(present(fast_protected_N))fast_protected_N=>pool%litterCohorts(1:n)%protectedN(1)
    IF(present(slow_protected_N))slow_protected_N=>pool%litterCohorts(1:n)%protectedN(2)
    IF(present(deadMicrobe_protected_N))deadMicrobe_protected_N=>pool%litterCohorts(1:n)%protectedN(3)

    IF(present(IMM_N_max))IMM_N_max=>pool%litterCohorts(1:n)%IMM_N_max
    IF(present(IMM_N_gross))IMM_N_gross=>pool%litterCohorts(1:n)%IMM_N_gross
    IF(present(MINER_gross))MINER_gross=>pool%litterCohorts(1:n)%MINER_gross
    IF(present(MINER_prod))MINER_prod=>pool%litterCohorts(1:n)%MINER_prod
    IF(present(IMM_Nprod))IMM_Nprod=>pool%litterCohorts(1:n)%IMM_Nprod

    IF(present(fast_DOC)) fast_DOC=>pool%dissolved_carbon(1)
    IF(present(slow_DOC)) slow_DOC=>pool%dissolved_carbon(2)
    IF(present(deadMicrobe_DOC)) deadMicrobe_DOC=>pool%dissolved_carbon(3)
    IF(present(fast_DON)) fast_DON=>pool%dissolved_nitrogen(1)
    IF(present(slow_DON)) slow_DON=>pool%dissolved_nitrogen(2)
    IF(present(deadMicrobe_DON)) deadMicrobe_DON=>pool%dissolved_nitrogen(3)
    IF(present(ammonium)) ammonium=>pool%ammonium
    IF(present(nitrate)) nitrate=>pool%nitrate
    IF(present(nitrif)) nitrif=>pool%nitrif
    IF(present(denitrif)) denitrif=>pool%denitrif

end subroutine get_pool_data_accessors


#else

subroutine error_mesg(routine,message,level)
    character(len=*),intent(in)::routine,message
    integer::level

    if(level.eq.FATAL) then
    print *,'Error in routine ',routine,': ',message
    stop
    else
    print *,'Note from routine ',routine,': ',message
    endif
end subroutine

!Copied from soil_numerics (by sergey malyshev)
! ============================================================================
! given values of the triadiagonal matrix coefficients, computes a solution
subroutine tridiag(a,b,c,r,u)
  real, intent(in)  :: a(:),b(:),c(:),r(:)
  real, intent(out) :: u(:)

  integer :: j
  real :: bet, gam(size(a))

  ! check that the sizes are the same
  if(size(a)/=size(b).or.size(a)/=size(c).or.size(a)/=size(r)) &
       call error_mesg('tridiag','sizes of input arrays are not equal',FATAL)
  if(size(u)<size(a)) &
       call error_mesg('tridiag','size of the result is insufficient',FATAL)
  ! check that a(1)==0 and c(N)==0
  if(a(1)/=0.or.c(size(a))/=0) &
       call error_mesg('tridiag','a(1) and c(N) must be equal to 0',FATAL)
  ! decomposition and forward substitution
  bet = b(1)
  u(1) = r(1)/bet
  do j = 2,size(a)
     gam(j) = c(j-1)/bet
     bet = b(j)-a(j)*gam(j)
     if(bet==0) &
          call error_mesg('tridiag','system is ill-defined',FATAL)
     u(j) = (r(j)-a(j)*u(j-1))/bet
  enddo
  ! backward substitution
  do j = size(a)-1,1,-1
     u(j) = u(j)-gam(j+1)*u(j+1)
  enddo
end subroutine tridiag


#endif

end module soil_carbon_mod
